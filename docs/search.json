[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción a la Programación II",
    "section": "",
    "text": "Prefacio\nLos conocimientos en programación son esenciales para la práctica de la ciencia de datos, que implica el manejo de grandes conjuntos de datos, junto con la creciente demanda de que los estudios sean reproducibles y abiertos. Con estas exigencias, quienes hacen ciencia de datos necesitan a menudo crear, utilizar y compartir software. Este software tiene características particulares, que están relacionadas en gran medida con la exploración de problemas y la respuesta a preguntas.\nEste libro se desarrollo para la materia Introduccion a la Programacion II y cubre los fundamentos de la creación de software como parte desarrollo y ejecución de proyectos de ciencia de datos abiertos y reproducibles, tanto si la persona trabaja sola como si forma parte de un equipo.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#introducción-para-estudiantes",
    "href": "index.html#introducción-para-estudiantes",
    "title": "Introducción a la Programación II",
    "section": "Introducción para estudiantes",
    "text": "Introducción para estudiantes\nEl objetivo principal de este libro es enseñarte las herramientas, habilidades y conocimientos necesarios para crear software abierto para hacer ciencia de datos de una forma reproducible y sostenible. Esta pensado para personas que investigan o practican ciencias de datos y que ya saben escribir funciones y programas de unos cientos de líneas de codigo y que quieren ser más productivos, tener más confianza en sus resultados y trabajar de forma abierta y reproducible.\nEste libro ofrece una introducción pragmática y basada en herramientas a la ingeniería de software de investigación. Para las personas cuyas tareas incluyen la creación de paquetes de software, este libro le ayudará a ser un ingeniero de software de investigacion. A diferencia de las personas que desarrollan software en la industria o los estudiantes de ciencias de la computacion, este libro utiliza el análisis de datos como ejemplo motivador y asume que el objetivo final de nuestros estudiantes es responder a preguntas y realizar analisis de datos.\nLa ciencia de datos es un proceso que depende de resultados que sean exactos, precisos, replicables y reproducibles. El desarrollo de paquetes de software con fines de investigación nos ayuda a garantizar que los análisis que producen nuestros resultados sean exactamente eso: exactos, precisos, replicables y reproducibles.\nTeniendo esto en cuenta, el principal objetivo de aprendizaje de este libro es que aprendas a gestionar proyectos de ciencia de datos y a desarrollar un paquete R. Al final del libro tendras las habilidades y conocimientos necesarios para: trabajar en proyectos de ciencias de datos ordenados, desarrollar paquetes de R bien construidos, bien documentados y reutilizables y trabajar eficazmente en equipo.\nEstos son los objetivos de aprendizaje específicos que dominarás con este libro:\n\nEscribir programas de R que resuelvan tareas de un proyecto de ciencia de datos.\nProgramar funciones en R.\nExplicar qué es un paquete R, cómo está estructurado y cómo crear uno.\nEnumerar y describir mejores prácticas en el desarrollo de paquetes y cómo implementarlas.\nExplicar qué es una guía de estilo de código, por qué es importante y cómo escribir código que se adhiera a la guía de estilo.\nDescribir por qué la documentación fácil de usar y bien escrita es crucial para construir un paquete utilizable y algunos pasos para lograr este tipo de documentación.\nAplicar técnicas de testeo de software a funciones y paquetes de R.\nDescribir diferentes posibilidades para publicar y compartir un paquete.\nUsar Git y GitHub para monitorear y compartir tu software.\nEncontrar y resolver errores en los programas de R desarrollados.\nEntender como funcionan, que rol y limitaciones tienen los asistentes de programación de IA.\nResolver casos reales de ciencia de datos aplicando las habilidades aprendidas durante la materia.\nOrganizar proyectos de ciencia de datos pequeños a medianos.\nIncorporar el valor del trabajo abierto y reproducible.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#visión-general-de-los-paquetes-creados",
    "href": "index.html#visión-general-de-los-paquetes-creados",
    "title": "Introducción a la Programación II",
    "section": "Visión general de los paquetes creados",
    "text": "Visión general de los paquetes creados\nA lo largo del libro, construirás un paquete de R para leer y analizar datos meteorológicos.\nUtilizaremos datos que diponibiliza el Institulo Nacional de Tecnología Agropecuaria INTA a traves del Sistema de Información y Gestión Agropecuaria SIGA.\nLuego de presentar un tema vamos a realizar ejercicios que nos hagan avanzar en nuestro objetivo de desarrollar este paquete de R en particular.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#sec-licensing",
    "href": "index.html#sec-licensing",
    "title": "Introducción a la Programación II",
    "section": "Reutilización y licencia",
    "text": "Reutilización y licencia\nTodo el material puede reutilizarse libremente bajo los términos de la licencia Creative Commons Reconocimiento 4.0 Internacional Licencia, esto significa que el material puede utilizarse, reutilizarse y modificarse, siempre que se cite esta fuente.\nEl código fuente del libro se encuentra en el repositorio de GitHub intro-programacion. Cualquier corrección, o contribuciones son bienvenidas. Visitá nuestra página sobre como contribuir]() para conocer más.\n\nPrerequisitos\nPara seguir este libro, necesitarás tener instalado git, R y RStudio. Si no los tienes instalados, puedes seguir las instrucciones en la página de instalación.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#convenciones-en-el-libro",
    "href": "index.html#convenciones-en-el-libro",
    "title": "Introducción a la Programación II",
    "section": "Convenciones en el libro",
    "text": "Convenciones en el libro\nEl libro esta ordenado en capitulos que abarcan un tema en particular. Dentro del capitulo podemos presentar ejercicios, ejemplos, consejos, advertencias, etc. Para diferenciar estos elementos utilizamos los siguientes bloques:\n\nEste es un ejercicio\n\n\nEste es un ejemplo\n\n\nA tener en cuenta!\n\n\nEste es un consejo",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#bibliografia",
    "href": "index.html#bibliografia",
    "title": "Introducción a la Programación II",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nGeneral Obligatoria\n\nR Packages (2e) de Hadley Wickham y Jennifer Bryan. Disponible de manera gratuita: https://r-pkgs.org/\nR for Data Science (2e) de Hadley Wickham, Mine Cetinkaya-Rundel y Garrett Grolemund. Disponible de manera gratuita: https://r4ds.hadley.nz/. Primera edición en español: https://es.r4ds.hadley.nz/\n\n\n\nComplementaria\n\nAdvance R de Hadley Wickham. Disponible de manera gratuita: https://adv-r.hadley.nz/\nResearch Software Engineering with Python: Building software that makes research possible de Damien Irving, Kate Hertweck, Luke Johnston, Joel Ostblom, Charlotte Wickham, y Greg Wilson. Disponible de manera gratuita: https://third-bit.com/py-rse/\nrOpenSci editorial team (2024). Paquetes rOpenSci: Desarrollo, mantenimiento y revisión por pares [rOpenSci Packages: Development, Maintenance, and Peer Review] (Traducción al español: Yanina Bellini Saibene, Elio Campitelli, Paola Corrales) Zenodo. https://zenodo.org/doi/10.5281/zenodo.10797248 (Trabajo original publicado en 2024). Disponible de manera gratuita: https://devguide.ropensci.org/es/index.es.html",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "index.html#fuentes",
    "href": "index.html#fuentes",
    "title": "Introducción a la Programación II",
    "section": "Fuentes",
    "text": "Fuentes\nEste libro utilizo como fuentes los siguientes materiales:\n\nResearch Software Engineering with Python: Building software that makes research possible de Damien Irving, Kate Hertweck, Luke Johnston, Joel Ostblom, Charlotte Wickham, y Greg Wilson. Disponible de manera gratuita: https://third-bit.com/py-rse/\nR for Data Science (2e) de Hadley Wickham, Mine Cetinkaya-Rundel y Garrett Grolemund. Disponible de manera gratuita: https://r4ds.hadley.nz/. Primera edición en español: https://es.r4ds.hadley.nz/",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00_intro.html",
    "href": "00_intro.html",
    "title": "\n1  Presentación\n",
    "section": "",
    "text": "1.1 Te presentamos R y RStudio\nNo existe un acuerdo sobre una definición formal de ciencia de datos, pero la mayoría de estas definiciones concuerda en que tiene al menos tres pilares: el conocimiento estadístico, el conocimiento de ciencias de la computación y el conocimiento de área sobre el cual se va a aplicar.\nEl proceso de ciencia de datos en el cual nos vamos a basar se puede ver en el siguiente diagrama:\nPrimero, debes importar tus datos hacia la herramienta donde vas a procesarlos. Típicamente, esto implica tomar datos que están guardados en un archivo o base de datos y cargarlos en tu software para poder trabajar con ellos.\nUna vez que has importado los datos, el siguiente paso es ordenarlos para que tengan un formato adecuado para su análisis. Este formato pensado para el análisis tiene la característica que, en los conjuntos de datos ordenados, cada columna es una variable y cada fila una observación. Tener datos ordenados nos provee una estructura consistente, preparada para analizarlos y podemos enfocar nuestros esfuerzos en las preguntas que queremos contestar con nuestros datos y no tener que acomodarlos cada vez que la pregunta cambie.\nCuando tus datos están ordenados, podemos necesitar transformarlos. La transformación implica quedarte con las observaciones que sean de interés (como todos los lugares donde se registra temperatura minima o todos los datos del último año), crear nuevas variables que a partir de variables ya existentes (como calcular la amplitud termica de un lugar al restar la temperatura máxima y mínima registradas en ese lugar) y calcular una serie de estadísticos de resumen (como recuentos y medias).\nUna vez que tienes los datos ordenados con las variables que necesitas, hay dos principales fuentes generadoras de conocimiento: la visualización y el modelado. Ambas tienen fortalezas y debilidades complementarias, por lo que cualquier análisis va a utilizarlas varias veces aprovechando los resultados de una para alimentar a la otra.\nLa visualización es una herramienta fundamental. Una buena visualización te mostrará el patrón de los datos, cosas que tal vez no esperabas o te hará surgir nuevas preguntas. También puede ayudarte a replantear tus preguntas o darte cuenta si necesitas recolectar datos diferentes.\nLos modelos son herramientas complementarias a la visualización. Una vez que tus preguntas son lo suficientemente precisas, puedes utilizar un modelo para responderlas. Los modelos son herramientas estadísticas o computacionales y tienen supuestos para poder aplicarlos, así que la tarea de seleccionar el modelo adecuado para nuestro problema es una parte importante de este proceso, como también lo es su implantación e interpretación posterior.\nEl último paso en el proceso de la ciencia de datos es la comunicación, una parte crítica de cualquier proyecto de análisis de datos, porque es cuando vas a mostrar tus resultados a otras personas y necesitas que puedan comprenderlos y encontrarlos útiles para utilizarlos.\nAlrededor de todas estas herramientas se encuentra la programación como herramienta transversal en el proyecto de ciencia de datos. No necesitás ser una persona experta en programación para hacer ciencia de datos, pero aprender más sobre programar te ayudará a automatizar tareas recurrentes, compartir tu trabajo de forma reusable y aprovechar el trabajo de otros para resolver problemas similares con mayor facilidad y rapidez.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Presentación</span>"
    ]
  },
  {
    "objectID": "00_intro.html#te-presentamos-r-y-rstudio",
    "href": "00_intro.html#te-presentamos-r-y-rstudio",
    "title": "\n1  Presentación\n",
    "section": "",
    "text": "1.1.1 Orientándose en RStudio\nEn principio se podría escribir código de R con el Bloc de Notas y luego ejecutarlo, pero nosotros vamos a usar RStudio, que brinda una interfaz gráfica con un montón de herramientas extra para hacernos la vida más fácil.\nCuando abras RStudio te vas a encontrar con una ventana con cuatro paneles como esta:\n\n\nVentana de RStudio\n\nLos dos paneles de la izquierda son las dos formas principales de interactuar con R. El panel de abajo a la izquierda es la consola. Es el lugar que te permite conversar con R. Podés escribir comandos que se van a ejecutar inmediátamente cuando aprietes Enter y cuyo resultado se va a mostrar en la consola.\nPor ejemplo, hacé click en la consola, escribí 2 + 2 y apretá Enter. Vas a ver algo como esto:\n\n2 + 2\n\n[1] 4\n\n\nLe dijiste a R que sume 2 y 2 y R te devolvió el resultado: 4 (no te preocupes del [1] por ahora). Eso está bueno si querés hacer una cuenta rápida o chequear algo pequeño, pero no sirve para hacer un análisis complejo y reproducible.\nEn el panel de arriba a la izquierda tenemos esencialmente un editor de texto. Ahí es donde vas a escribir si querés guardar instrucciones para ejecutarlas en otro momento y donde vas a estar el 87% de tu tiempo usando R.\nA la derecha hay paneles más bien informativos y que tienen varias solapas que vamos a ir descubriendo a su tiempo. Para destacar, arriba a la derecha está el “environment”, que es forma de ver qué es lo que está “pensando” R en este momento. Ahí vas a poder ver un listado de los datos que están abiertos y otros objetos que están cargados en la memoria de R. Ahora está vacío porque todavía no cargaste ni creaste ningún dato. Abajo a la derecha tienen un explorador de archivos y también el panel de ayuda, que es donde vas a pasar el otro 13% del tiempo usando R.\nEntonces, para resumir:\n\n\nLa cocina de RStudio\n\n\n1.1.2 Hablando con R\nYa viste cómo usar R como una calculadora.\n\n2 + 2\n\n[1] 4\n\n\nR entiende un montón de operaciones aritméticas escritas como seguramente ya te imaginás:\n\n\n+: sumar\n\n-: restar\n\n*: multiplicar\n\n/: dividir\n\n^ o **: exponenciar\n\nPero además conoce muchas otras operaciones. Para decirle a R que calcule el seno de 1 hay que escribir esto:\n\nsin(1)\n\n[1] 0.841471\n\n\nLa sintaxis básica para aplicar cualquier función es nombre_funcion(argumentos).\n\nEn la consola escribí el código de R para calcular las siguientes operaciones:\n\n2 multiplicado por 2\n3 al cuadrado\ndos tercios\n5 por 8 más 1\n\n\nAl hacer todas estas operaciones, lo único que hiciste fue decirle a R que haga esos cálculos. R te devuelve el resultado, pero no lo guarda en ningún lado. Para decirle que guarde el resultado de una operación hay que decirle con qué “nombre” querés guardarlo. El siguiente código hace eso:\n\nx &lt;- 2 + 2\n\nLa “flechita” &lt;- es el operador de asignación, que le dice a R que tome el resultado de la derecha y lo guarde en una variable con el nombre que está a la izquierda. Vas a ver que no te devele el resultado. Para verlo, ejecutamos\n\nx\n\n[1] 4\n\n\nEsto le dice a R que te “imprima” el contenido de la variable x.\n\n¿Qué te imaginás que va a pasar cuando ahora corra el siguiente código?\n\nx + 2\n\n\nPonerle nombre a las variables es a veces la parte más difícil de escribir código. A R le viene bien cualquier nombre de variable siempre y cuando no empiece con un número o un “_”. Pero a los seres humanos que lean el código y tengan que interpretarlos les va a resultas más fácil entender qué hace la variable promedio_temperatura que la variable xxy1.\nEl consejo es tratar en lo posible usar nombre descriptivos y consistentes. Por ejemplo, siempre usar minúsculas y separar palabras con “_”.\n\nPara hacerse la vida más fácil existen “guías de estilo” para programar que explicitan reglas específicas para escribir código. Por ejemplo esta o esta otra. Se trata de reglas únicamente para los ojos humanos, y que no afectan en absoluto la eficiencia o correctitud de la programación. En general, no existen guías buenas o malas, la idea es elegir una y ser consistente. De esta manera, vas a poder entender tu código con más facilidad.\n\n\n1.1.3 Extendiendo R\nR es un lenguaje creado por personas que practican la estadística y pensado para la estadística, por lo que ya viene con un montón de métodos estadísticos incorporados, como mean() o median(). Pero hay tantos métodos estadísticos como gente haciendo estadística así que es imposible que estén todos. La solución es que podés “agregarle” a R funciones que no vienen instaladas por defecto pero que escribieron otras personas en forma de “paquetes”. ¡Este es el poder de la comunidad de R!\nPara instalar paquetes de R, la forma mas fácil es con la función install.packages(). Esta función se conecta a internet y descarga paquetes publicados en un repositorio oficial Entonces, por ejemplo,\n\ninstall.packages(\"readr\")\n\ndescarga e instala un paquete que contiene funciones para leer datos.\n\nPara instalar paquetes de esta forma es necesario tener conexión de internet.\n\nLuego, usando el comando\n\nlibrary(readr)\n\nle decís a R que cargue las funciones que vienen en el paquete readr para usarlas.\n\n\nInstalá el paquete readr con el comando install.packages(\"readr\") en la consola.\nCargá la librería para usarla con library(readr).\n\n\n\nSi cerrás y volveś a abrir R, vas a tener que usar library(readr) nuevamente para acceder a la funcionalidad del paquete readr. Sólo hace falta correr install.packages(\"readr\") una vez por computadora.\n\n\n1.1.4 Buscando ayuda\nEntre la enorme cantidad de funciones que tiene R por defecto y las que se pueden agregar instalando paquetes externos, es imposible recordar todas las funciones y cómo usarlas. Por eso, una gran proporción del tiempo que uses R vas a pasarlo leyendo documentación de funciones, ya sea para aprender a usarlas o porque no te acordás algún detalle.\nPara acceder a la ayuda de una función usamos el signo de pregunta:\n\n?sin\n\n\nOtra forma de acceder a la ayuda de una función es poniendo el cursor sobre ella y apretando F1\n\nEsto va a abrir el documento de ayuda para la función sin() que, como verás, tiene la documentación de las funciones trigonométricas que trae R por defecto. Todas las ayudas de R vienen divididas en secciones:\n\nDescription\n\nUna descripción breve de la función o funciones que se documentan.\n\nUsage\n\nNombre de los argumentos de la función. La mayoría de las funciones trigonométricas tienen un solo argumento, que se llama x. La función atan2() tiene dos argumentos, llamados x e y.\n\nArguments\n\nUna descripción de cada argumento. En este caso x e y son vectores numéricos o complejos. Aunque todavía no sepas qué es un “vector”, de esta descripción ya podés intuir que las funciones trigonométricas aceptan números complejos.\n\nDetails\n\nUna descripción detallada de las funciones. Por ejemplo, detalla qué es lo que devuelve la función atan2(), describe las unidades en las que tienen que estar x e y, etc..\n\nValue\n\nDescribe qué tipo de valor devuelve la función.\n\nExamples\n\n(abajo de todo) Es la sección más importante y probablemente la que vas a buscar primero cuando te encuentres con una función nueva que no sabés cómo usar. Acá vas a encontrar código de R de que ejemplifica el uso típico de la función. Podes copiar y pegar el código en la consola y ver el resultado para entender como funciona.\n\n(Otras secciones)\n\nPueden haber otras secciones que detallen distintas particularidades de la función, o referencias a los métodos implementados.\n\n\n\nAbrí y leé la ayuda de la función sd(). Puede que haya cosas que aún no entiendas, pero intentá captar la idea general. Si encesitas traducir la documentación, te recomendamos deepl.\n\n¿Qué hace esa función?\n¿Qué argumentos acepta?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Presentación</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html",
    "href": "01_proyectos.html",
    "title": "\n2  Entorno de trabajo\n",
    "section": "",
    "text": "2.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#objetivos-de-aprendizaje",
    "href": "01_proyectos.html#objetivos-de-aprendizaje",
    "title": "\n2  Entorno de trabajo\n",
    "section": "",
    "text": "Interactuar con la interfaz de RStudio para navegar archivos y directorios\nInterpretar las rutas como ubicaciones dentro de las carpetas\nCrear proyectos RStudio e identificar el directorio de trabajo\nReconocer los paneles de la interfaz de RStudio y sus ubicaciones por defecto",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#el-problema",
    "href": "01_proyectos.html#el-problema",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.2 El problema",
    "text": "2.2 El problema\nImagina que arrancas el cuatrimestre y tenes que continuar con un proyecto de análisis de datos. O mejor te tomaste unas largas vacaciones. Por supuesto, todo el código y los datos están en una única carpeta y además lo publicaste en un repositorio público. Es hora de volver a trabajar, pero ¿qué fue lo último que hiciste? ¿qué falta?.\nEmpezas a revisar la carpeta del proyecto y encuentras algo así.\n/home/dorothy/Documentos/proyecto\n├── resumen.R\n├── correlation.png\n├── datos.csv\n├── datos2.csv\n├── fig1.png\n├── figura2(copy).png\n├── figura.png\n├── figura1.png\n├── figura10.png\n├── datos_crudos.csv\n├── script.R\n└── script_final.R\nY no tienes ni idea por donde arrancar. Hay tres archivos .R que podrían ser el script con el código que escribiste, varios posibles archivos que contienen algunos “datos” no especificados y un montón de archivos de imagenes con nombres que dan poca información sobre su contenido. Sin un archivo README (documento descriptivo) ni ninguna otra documentación que te ayude a resolver este lío, es muy posible que cueste mucho tiempo volver al punto en el que estabas y continuar con tu trabajo.\nPara evitar esta situación necesitamos tener en cuenta la reproducibilidad y el desarrollo de software desde el inicio. La reproducibilidad tiene que ver tanto con las personas que interactúan con el código como con las máquinas que deben ejecutarlo. Hacer que tu código y análisis sea reproducible es permitir que otras personas (y vos en el futuro) puedan revisar, usar y ampliar tu trabajo. Esto requerira aplicar distintos principios de programación y desarrollo de software que veremos a lo largo del curso. Empecemos organizando el trabajo.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#crear-un-proyecto-organizado",
    "href": "01_proyectos.html#crear-un-proyecto-organizado",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.3 Crear un proyecto organizado",
    "text": "2.3 Crear un proyecto organizado\nLo que cuenta como “organizado” es muy personal, pero lo principal es que la estructura de carpetas y los nombres de los archivos deben:\n\nser autodocumentados\nser útiles a la hora de escribir código\nestar en el mismo lugar, es decir, todos los archivos necesarios están dentro de la carpeta raíz\n\n\n2.3.1 Archivos que se autodocumentan\nAprovechá carpetas con nombres informativos para autodocumentar las distintas partes de tu análisis.\nColoca tus datos en datos, los scripts de preprocesamiento en scripts o preprocesamiento y tu análisis en analisis. Utiliza también subcarpetas, como datos/crudos para guardar los datos originales y datos/derivados para los datos preprocesados y depurados.\nNombrá tus archivos de modo que puedas saber que incluyen aún si pasaron 10 años desde que los creaste.\nUtiliza nombres cortos, descripciones breves de lo que hay dentro.\n\nDescribi cuál crees que es el contenido de estos archivos:\n\ndatos/crudos/madrid_temperatura-minima.csv\nscripts/02_calcula_temperatura-media.R\nanalysis/01_madrid_temperatura-minima_analisis-estadistico.Rmd\n\n\n\nPensá en buenos nombres de archivos y carpetas para:\n\nun conjunto de datos sobre gatos con columnas para el peso, la longitud, la longitud de la cola, el color o colores del pelaje, el tipo de pelaje y el nombre.\nun script que descarga datos de Spotify.\nun script que limpia los datos de Spotify.\nun script que ajusta un modelo lineal y lo guarda en un archivo.\nel archivo .Rds en el que se guarda ese modelo.\n\n\n\nUtiliza una estructura de carpetas conocida\nNo existe una única estructura de carpetas objetivamente mejor. En caso de duda, intenta seguir las convenciones de tu comunidad de investigación. Esto minimizará cualquier fricción entre tú y tu público potencial.\n\n\n2.3.2 Archivos con los que puedes programar\nRecuerda siempre que las computadoras son bastante tontas, así que sé amable y utiliza nombres de archivo que puedan entender fácilmente.\nEn algunos casos, los nombres de archivo con espacios confunden a las computadoras, por lo que en general es mucho más fácil trabajar si los nombres de archivo utilizan guiones para dividir las palabras. Del mismo modo, algunas máquinas no pueden manejar “caracteres especiales” como la “ñ” o las tildes. También es mejor evitar algunos símbolos (“.”, “*”, y otros) porque tienen un significado especial en las expresiones regulares.\nAlgunos sistemas de archivos no distinguen entre mayúsculas y minúsculas, por lo que Temperatura-Madrid.csv y temperatura-madrid.csv pueden ser el mismo archivo.\nPara evitar dolores de cabeza, es mejor y por el lado conservador y solo utilizar caracteres latinos en minúsculas, números y guiones (“_” y “-”).\nUtiliza guiones como separadores. Puedes utilizar “-” para separar palabras que formen parte del mismo concepto y “_” para separar conceptos. Por ejemplo temperatura-minima_buenos-aires.csv, en este caso temperatura-minima es un cocepto y buenos-aires otro. Recomendamos esta convención y no al revés, porque es compatible con el formato de fecha ISO (“AAAA-MM-DD”).\n\nSi utilizás los separadores de forma coherente e inteligente, podrás analizar los nombres de los archivos como parte de tu código. Por ejemplo, si tienes\n\narchivos\n\n[1] \"madrid_temperatura-minima\"       \"buenos-aires_temperatura-minima\"\n[3] \"madrid_temperatura-maxima\"       \"buenos-aires_temperatura-maxima\"\n\n\nTambién podrías extraer ciudades y nombres de variables desde los nombres de los archivos\n\nstrsplit(archivos, \"_\")\n\n[[1]]\n[1] \"madrid\"             \"temperatura-minima\"\n\n[[2]]\n[1] \"buenos-aires\"       \"temperatura-minima\"\n\n[[3]]\n[1] \"madrid\"             \"temperatura-maxima\"\n\n[[4]]\n[1] \"buenos-aires\"       \"temperatura-maxima\"\n\n\n\nPor último, intentá que tus archivos sean fácilmente ordenables. Comezá el nombre del archivo con números (que incluya suficientes ceros a la izquierda) y, si aplica, utilizá fechas en formato AAAA-MM-DD para que el orden de los archivos por nombre coincida con el orden por fecha.\n\n2.3.3 Que tu proyecto sea autocontenido\nUn aspecto importante a la hora de pensar en tu proyecto es que todos los scripts, datos, figuras y cualquier otra cosa que se necesite para (re)crear el análisis esté dentro de la misma carpeta raíz. De ese modo te aseguras de que lo único que tienes que dar a otra persona para que ejecute correctamente tu código es esa única carpeta. También te facilita la vida si trabajas en el mismo proyecto en distintas computadoras, ya que te permite sincronizar una única carpeta.\n\nMás adelante veremos como empaquetar código para compartirlo con otras personas.\n\nUn paso extra a tener en cuenta es que no puedes hacer que tu trabajo sea portable si tu código no lo es también. Quizás el principal culpable de que el código no sea portable sea utilizar rutas absolutas para manipular archivos en tu código.\nLa siguiente línea de código lee el archivo datos.csv:\n\nread.csv(\"/home/dorothy/Documentos/proyectos/mitrabajo/datos/datos.csv\")\n\nAunque hayas descargado correctamente la carpeta mitrabajo desde algún repositorio, este código va a dar error porque es poco probable que hayas guardado esa carpeta dentro de Documentos/proyectos y que tu nombre de usuario en la computadora sea “dorothy”.\nEn cambio, podes utilizar una ruta relativa:\n\nread.csv(\"datos/datos.csv\")\n\nEsto se ejecutará independientemente de dónde se encuentre la carpeta raíz de tu proyecto ya que hace referencia solo a lo que está adentro. Como veremos a continuación los proyectos de RStudio ayudan a definir cual es la carpeta raíz de manera automática.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#proyectos-de-rstudio",
    "href": "01_proyectos.html#proyectos-de-rstudio",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.4 Proyectos de RStudio",
    "text": "2.4 Proyectos de RStudio\nRStudio proporciona una forma ordenada y estructurada de separar tus proyectos en diferentes contextos. No ayudan estrictamente a la reproducibilidad del producto final, pero te ayudarán a agilizar tu flujo de trabajo encapsulando cosas como la lista de archivos abiertos, el historial de comandos de R y la configuración de RStudio para cada proyecto.\nAbrir un proyecto de RStudio también garantiza que inicies una nueva sesión de R cada vez y establece tu directorio de trabajo en la carpeta raíz del proyecto.\n\nCreá un nuevo proyecto de RStudio\n\nHace clic en “File” y luego en “New Project…”.\nHace clic en “New directory”.\nVerás una lista de varias plantillas. Selecciona “New project”.\nEscribí el nombre de la carpeta raíz en la que vivirá tu proyecto y selecciona la ubicaciónn en la que quieres que se cree esta carpeta haciendo clic en “Browse”.\nHace clic en “Create project”.\n\n\n¿Cuál es la ruta absoluta a la carpeta de tu proyecto?\nSi cerrás RStudio, ¿cómo podés asegurarte de que tu carpeta de trabajo es la carpeta de tu proyecto la próxima vez que abras RStudio?\n\n\nSi todo salió bien, deberías tener una nueva carpeta con el nombre que elejiste para tu proyecto. Es una carpeta común y corriente; lo que la distingue como proyecto de RStudio es el archivo .Rproj, que contiene las opciones de RStudio específicas del proyecto, y la carpeta oculta .Rproj.user, donde se encuentran los archivos temporales específicos del proyecto.\nCada proyecto de RStudio tiene su propio conjunto de opciones que podés cambiar sin alterar las opciones globales ni las de otros proyectos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#abrir-un-proyecto",
    "href": "01_proyectos.html#abrir-un-proyecto",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.5 Abrir un proyecto",
    "text": "2.5 Abrir un proyecto\nLa forma más sencilla de abrir un proyecto es abrir la carpeta que lo contiene y hacer doble clic en el archivo .Rproj. También puedes abrir rápidamente un proyecto utilizado recientemente haciendo clic en el icono de proyecto situado a la derecha de la barra de herramientas de RStudio.\nEsto abrirá una nueva ventana de RStudio con su propia sesión de R y la carpeta del proyecto será el directorio o carpeta raiz. Por defecto, también abrirá los archivos abiertos anteriormente. Incluso conservará los cambios no guardados. Esto ayuda a mantener tu trabajo ordenado y facilita retomar o compartir lo que has hecho más tarde.\nRStudio te permite tener abiertos varios proyectos, y esto es posible porque cada proyecto tiene su propia carpeta. Puedes trabajar con varios proyectos en paralelo sin que el código o los resultados de un análisis interfieran con los de otro.\n\nAbrí tu proyecto\n\nEn tu nuevo proyecto, crea un nuevo archivo .R y escribe algo de código (por ejemplo print(\"Hola!\") o x &lt;- 2 + 2), no te olvides de guardarlo.\nCerrá la ventana de RStudio.\nAhora abrí una nueva ventana de RStudio y el proyecto de RStudio que acabas de cerrar (dependiendo de tus opciones globales, puede que se abra por defecto).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "01_proyectos.html#borrón-y-cuenta-nueva-todos-los-días",
    "href": "01_proyectos.html#borrón-y-cuenta-nueva-todos-los-días",
    "title": "\n2  Entorno de trabajo\n",
    "section": "\n2.6 Borrón y cuenta nueva… todos los días",
    "text": "2.6 Borrón y cuenta nueva… todos los días\n¿Cómo garantizamos que el análisis sea realmente reproducible? Es una pregunta bastante amplia y existen muchas herramientas para resolver este problema. Por ahora vamos a concentrarnos en que, al menos en tu computadora, puedas repetir los cálculos o el análisis desde cero. Y además de organizar los proyectos y no modificar los datos originales, ¿cómo podés asegurarte de guardar todo el código que estuviste usando y genera el análisis? La forma más directa es reiniciar la sesión de R y volver a ejecutar el código, si da un error o no devuelve lo que esperabas significa que te has saltado un paso.\n\nPuedes reiniciar la sesión de R con el atajo de teclado Ctrl+Shif+F10.\n\nEsto puede ocurrir si, por ejemplo, lees datos en memoria ejecutando un comando en la consola. Mientras trabajamos, R tendrá esos datos en memoria y podrás hacer cálculos y gráficos, pero tu código no será reproducible porque le falta el paso importante de leer los datos.\nLa mejor forma de asegurarte de que esto no ocurra es volver a ejecutar tu código en una sesión nueva de R a menudo, para asegurarte de que tu código es reproducible en cada paso del análisis. Sin embargo, por defecto RStudio guardará el entorno en un archivo oculto llamado .RData y lo restaurará al iniciarse, de modo que los datos seguirán estando en la memoria. Y aunque esto resulta útil para que puedas arrancar tu trabajo exactamente donde lo dejaste cada vez que abras tu proyecto, puede llevar a una situación en la que nunca te des cuenta de que se te pasó guardar una línea de código clave en tu análisis.\n\nConfigurá tu proyecto\n\nVe a “Tools” -&gt; “Project options…”.\nEn la pestaña “General”\n\n\nDestildar la opción “Restore .RData into the workspace at startup”\n“Save workspace to .RData on exit”: Selecciona “Never” en el menú desplegable\n\n\n\nPuedes cambiar estas preferencias a nivel global con “Tools” -&gt; “Global Options” en la sección “General”\n\n\n2.6.1 Recursos\nEstructura del proyecto - Diapositivas de Danielle Navarro\nEmpaquetar el trabajo analítico de datos de forma reproducible utilizando R (y amigos)\nCómo (y por qué) hacer un compendio de investigación",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "02_lectura.html",
    "href": "02_lectura.html",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "",
    "text": "3.1 Trabajando con datos\nMuchas veces los datos están disponibles en distintos servicios en páginas de internet. Muchos gobiernos por ejemplo, tienen portales de datos abiertos. Organizaciones generan APIs (Interfaz de programación de aplicaciones, Application programming interface en Ingles) para poner a disposición sus datos o tal vez otras personas publicaron sus datos en servicios como Zenodo y queremos aprovecharlos. Es posible que se puedan decargar los datos visitando la web y haciendo click en un botón, sin embargo podríamos escribir el código necesario para hacer esto de manera programática. Esto hace que nuestro trabajo sea más reproducible y disminuye las chances de error.\nEl código que genera la descarga de datos podría estar incluido en el archivo de análisis de datos si la descarga no demora. En general querremos incluir la opción de no descargar los datos si el código encuentra que ya fueron descargados previamente. También podríamos generar un script de descarga de datos que corra una sola vez. Esta es una buena idea cuando el código de descarga demora o es complejo.\nVeamos un ejemplo de descarga de datos desde Zenodo.\nSi revisamos la base de datos https://zenodo.org/records/12772944 veremos que incluye un solo archivo en formato .csv.\nVemos también el botón “Download” para la descarga del archivo. Podríamos usarlo para descargar el archivo haciendo click.\nPero como mencionaba previamente, se puede escribir el código necesario para hacer la descarga de manera programática y asegurarnos que tenemos los datos correctos y actualizados.\nPara eso, primero necesitás la dirección (URL) del set de datos. Eso se consigue yendo a la página del set de datos y en vez de hacer click en Download, haciendo\nLa URL de esta base de datos es https://zenodo.org/records/12772944/files/pinguinos.csv?download=1. Guardamos eso en una variable en R\npinguinos_url &lt;- \"https://zenodo.org/records/12772944/files/pinguinos.csv?download=1\"\nY también definimos la ruta donde descargar el archivo\npinguinos_archivo &lt;- \"datos/pinguinos.csv\" # esta ubicación, o sea la carpeta datos debe existir!\nY finalmente usamos la función download.file() para descargar el archivo.\ndownload.file(url = pinguinos_url, destfile = pinguinos_archivo)\nY esto va a descargar la última versión de los datos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "02_lectura.html#trabajando-con-datos",
    "href": "02_lectura.html#trabajando-con-datos",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "",
    "text": "Click derecho → Copiar dirección del enlace",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "02_lectura.html#leer-datos-csv",
    "href": "02_lectura.html#leer-datos-csv",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "\n3.2 Leer datos csv",
    "text": "3.2 Leer datos csv\nExisten muchas funciones distintas para leer datos dependiendo del formato en el que están guardados. Para datos tabulares (filas y columnas), la forma más útil es el formato csv, que es un archivo de texto plano con datos separados por coma.\nEn R hay muchas maneras de hacer cada cosa, por ejemplo podríamos leer el archivo con la función read.csv(), con read_csv() del paquete readr o fread() del paquete data.table entre otras opciones. Nos vamos a quedar con la opción que nos da readr que tiene algunas características interesantes.\n\nlibrary(readr)\npinguinos &lt;- read_csv(\"datos/pinguinos.csv\")\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): especie, isla, sexo\ndbl (5): largo_pico_mm, alto_pico_mm, largo_aleta_mm, masa_corporal_g, anio\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nNotá que en este caso el código para leer los datos consta de dos líneas. La primera carga el paquete readr y el segundo usa la función read_csv() (del paquete readr) para leer el archivo .csv. No es necesario cargar el paquete cada vez que vas a leer un archivo, pero asegurate de incluir la carga de paquetes al comienzo de tu codigo.\n\nTodo ese texto naranja/rojo es intimidante pero no te preocupes, es sólo un mensaje que nos informa que los datos se leyeron y qué tipo de dato tiene cada columna. Podemos explorar la estructura de la variable pinguinos usando la función str() (de structure en inglés).\n\nstr(pinguinos)\n\nspc_tbl_ [344 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ especie        : chr [1:344] \"Adelia\" \"Adelia\" \"Adelia\" \"Adelia\" ...\n $ isla           : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ largo_pico_mm  : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ alto_pico_mm   : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ largo_aleta_mm : num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ masa_corporal_g: num [1:344] 3750 3800 3250 NA 3450 ...\n $ sexo           : chr [1:344] \"macho\" \"hembra\" \"hembra\" NA ...\n $ anio           : num [1:344] 2007 2007 2007 2007 2007 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   especie = col_character(),\n  ..   isla = col_character(),\n  ..   largo_pico_mm = col_double(),\n  ..   alto_pico_mm = col_double(),\n  ..   largo_aleta_mm = col_double(),\n  ..   masa_corporal_g = col_double(),\n  ..   sexo = col_character(),\n  ..   anio = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nEsto nos dice un montón. La primera línea dice que es una tibble, que es un caso especial de la estructura de datos tabular básica de R llamada data.frame. Tiene 344 filas (las observaciones) y 8 columnas (o variables que describen las observaciones). Las siguientes líneas nos dicen los nombres de las columnas (especie, isla, largo_pico_mm, alto_pico_mm, largo_aleta_mm, masa_corporal_g, sexo, y anio), su tipo de dato (chr o num), la longitud ([1:344]) y sus primeros elementos.\n\nEn el portal de datos de Argentina encontramos muchos conjuntos de datos con informacion oficial. Vamos a descargar y leer un archivo de Excel.\n\nDirigirse a esta pagina web con datos abiertos: https://datos.gob.ar/dataset/produccion-innovacion-productiva-empresas-que-mas-invierten-id-nivel-mundial\nRealizar los pasos necesarios para descargar el archivo de Excel del conjunto de datos “Las 50 empresas más innovadoras entre 2013 y 2019” de forma programatica.\nCargar el conjunto de datos en r y explorar su estructura con la función str().\nContestar:\n\n4.1 ¿Cuántas columnas y filas tiene el data.frame?\n4.2 ¿Qué tipo de dato hay en cada columna? ¿el tipo de dato es correcto según el contenido que vez?\n4.3 ¿Que funcion usaste para leer el archivo de Excel?\nAl final del ejercicio deberías tener un archivo .qmd o .R con el código que lo resuelve. Nombrá el archivo siguiendo los consejos que vimos en clase.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "02_lectura.html#ex-lectura",
    "href": "02_lectura.html#ex-lectura",
    "title": "\n3  Lectura de datos ordenados\n",
    "section": "\n3.3 Construyendo un paquete de R paso a paso",
    "text": "3.3 Construyendo un paquete de R paso a paso\n\nA lo largo del curso vamos a construir y probar paquete de R que nos permita trabajar y analizar datos de estaciones meteorológicas. El objetivo de este ejercicio es que comiences a familiarizarte con estos datos.\nUtilizaremos datos que diponibiliza el Institulo Nacional de Tecnología Agropecuaria INTA a traves del Sistema de Información y Gestión Agropecuaria SIGA. Por ahora y para practicar lo que vimos en esta sección, usaremos una parte de esos datos que guardamos en un repositorio.\n\nMetadatos: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/metadatos_completos.csv\nEstación NH0472: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/NH0472.csv\nEstación NH0910: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/NH0910.csv\nEstación NH0046: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/NH0046.csv\nEstación NH0098: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/NH0098.csv\nEstación NH0437: https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/NH0437.csv\n\n\nEscribe el código necesario para descargar los archivos y guardalos en la carpeta datos de tu proyecto. Utiliza las url provistas en el listado. Piensa en nombres adecuados para tus archivos segun lo que vimos en el segundo capitulo.\nLee los datos descargados, para eso revisa la ayuda de la funcion read_csv()`.\nExplora la estructura de los data.frames con la función str(). También podés usar glimpse() del paquete dplyr\n\n\n¿Cuántas columnas tiene cada tabla? ¿son todas iguales?\n¿Qué tipo de dato hay en cada columna? ¿el tipo de dato es correcto según el contenido que vez?\n¿Cuántos registros hay que cada data frame?\n\n\n\n3.3.1 Recursos\nUsando Apache Arrow para analizar el padron electoral argentino del 2011",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Lectura de datos ordenados</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html",
    "href": "03_manipulacion-1.html",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "",
    "text": "4.1 Seleccionando columnas con select()\nEl paquete dplyr provee una enorme cantidad de funciones útiles para manipular y analizar datos de manera intuitiva y expresiva.\nEl espíritu detrás de dplyr es que la enorme mayoría de los análisis, por más complicados que sean, involucran combinar y encadenar una serie relativamente acotada de acciones (o verbos). En este curso vamos a centrarnos las cinco más comunes:\nPara usar dplyr primero hay que instalarlo (esto hay que hacerlo una sola vez por computadora) con el comando:\ny luego cargarlo en memoria con\nVolvé a cargar los datos de pingüinos (para un recordatorio, podés ir a Lectura de datos ordenados):\nPara quedarse únicamente con las columnas de especie y largo del pico, usá select()\nselect(pinguinos, especie, largo_pico_mm)\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows\n¿Dónde quedó este resultado? Si te fijás en la tabla pinguinos, su formato no cambió, sigue teniendo todas las columnas originales a pesar de nuestro select:\npinguinos\n\n# A tibble: 344 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\nselect() y el resto de las funciones de dplyr siempre generan una nueva tabla y nunca modifican la tabla original. Para guardar la tabla con las dos columnas especie e largo_pico_mm tenés que asignar el resultado a una nueva variable.\npinguinos_isla &lt;- select(pinguinos, especie, largo_pico_mm)\npinguinos_isla\n\n# A tibble: 344 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 334 more rows",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#seleccionando-columnas-con-select",
    "href": "03_manipulacion-1.html#seleccionando-columnas-con-select",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "",
    "text": "Cómo funciona select()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#filtrando-filas-con-filter",
    "href": "03_manipulacion-1.html#filtrando-filas-con-filter",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.2 Filtrando filas con filter()\n",
    "text": "4.2 Filtrando filas con filter()\n\nAhora podés usar filter() para quedarte con sólo unas filas. Por ejemplo, para quedarse con los pingüinos de la especie Adelia:\n\nfilter(pinguinos, especie == \"Adelia\")\n\n# A tibble: 152 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 142 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\nLa mayoría de los análisis consisten en varios pasos que van generando tablas intermedias (en el primer desafío usaste 4 pasos para calcular la proporción entre el largo de la aleta y del pico) La única tabla que te interesa es la última, por lo que ir asignando variables nuevas en cada paso intermedio es tedioso y poco práctico. Para eso se usa el operador ‘pipe’ (|&gt;).\nEl operador ‘pipe’ (|&gt;) agarra el resultado de una función y se lo pasa a la siguiente. Esto permite escribir el código como una cadena de funciones que van operando sobre el resultado de la anterior.\nLas dos operaciones anteriores (seleccionar tres columnas y luego filtrar las filas correspondientes a Argentina) se pueden escribir uno después del otro y sin asignar los resultados intermedios a nuevas variables de esta forma:\n\npinguinos |&gt; \n  filter(especie == \"Adelia\") |&gt; \n  select(especie, largo_pico_mm)\n\n# A tibble: 152 × 2\n   especie largo_pico_mm\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 Adelia           39.1\n 2 Adelia           39.5\n 3 Adelia           40.3\n 4 Adelia           NA  \n 5 Adelia           36.7\n 6 Adelia           39.3\n 7 Adelia           38.9\n 8 Adelia           39.2\n 9 Adelia           34.1\n10 Adelia           42  \n# ℹ 142 more rows\n\n\nLa forma de “leer” esto es “Tomá los datos en el data.frame pinguinos, después aplicale filter() tal que la especie sea Adelia, después aplicale select() para quedarte con la especie y el largo_pico_mm.\n\nEs posible que te encuentres o te hayas encontrado con esta otra versión del operador pipe %&gt;%. Esta es la pipe del paquete magritter, que usamos durante muchísimo tiempo (y seguimos usando) hasta que la nueva pipe |&gt; se sumo a R 4.0.0.\n\nCómo vimos, el primer argumento de todas las funciones de dplyr es el data frame sobre el cual van a operar, pero notá que en las líneas con select() y filter() no escribís la tabla explícitamente.\nEsto es porque la pipe implícitamente pasa el resultado de las líneas anteriores como el primer argumento de la función siguiente.\nToma el data frame pinguinos y se lo pasa al primer argumento de filter(). Luego el data frame resultante de esa operación pasa como el primer argumento de la función select() gracias al |&gt;.\n\nEn RStudio podés escribir |&gt; usando el atajo de teclado Ctr + Shift + M. ¡Probalo!\n\n\nCompletá esta cadena de código para producir una tabla que contenga los pingüinos con aletas mayores a 200 mm y la información de la especie y el largo de la aleta.\n\npinguinos |&gt; \n  filter(largo_aleta_mm &gt; ___) |&gt; \n  select(_____, ____)\n\n\nComo seguramente notaste en el ejercicio cuando aplicamos filtros usamos operaciones lógicas que devuelven TRUE o FALSE según si cumplen o no con la condición. Para esto usamos operadores lógicos como ==, &gt;, &lt;, &gt;=, &lt;=, etc. R tiene varios operadores lógicos:\n\n\nOperador\nDefinición\n\n\n\n&lt;\nmenor que\n\n\nx|y\nx o y\n\n\n&lt;=\nmenor o igual a\n\n\nis.na(x)\nchequea si x es NA\n\n\n!is.na(x)\nchequea si x no es NA\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual a\n\n\nx %in% y\nchequea si x esta en y\n\n\n!(x %in% y)\nchequea si x no esta en y\n\n\n==\nigual a\n\n\n!=\nno igual a\n\n\n!x\nno x\n\n\nx & z\nx y z\n\n\n\n\nEs hora de revisar lo que vimos hasta acá.\n\nDescargá el archivo que se encuentra en este link y guardalo en tu proyecto de trabajo en clase.\nResolvé los ejercicios propuestos de lectura (yapa!) y de filtros. En algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nEl archivo tiene más ejercicios, pero no te adelantes. Vamos a ver esos temas a continuación.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#agrupando-y-reduciendo-con-group_by-summarise",
    "href": "03_manipulacion-1.html#agrupando-y-reduciendo-con-group_by-summarise",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.3 Agrupando y reduciendo con group_by() |> summarise()\n",
    "text": "4.3 Agrupando y reduciendo con group_by() |&gt; summarise()\n\nSi quisieramos responder ¿cuál es el largo promedio de la aleta para cada especie de pingüino? tenemos que usar un combo de funciones: group_by() |&gt; summarise(). Es decir, primero agrupamos las filas de nuestro data.frame según la columna especie (esto genera 3 grupos) y luego calculamos el promedio de largo_aleta_mm para cada grupo.\nVamos paso a paso.\n\npinguinos |&gt; \n  group_by(especie) \n\n# A tibble: 344 × 8\n# Groups:   especie [3]\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\nA primera vista parecería que la función no hizo nada, pero fijate que el resultado ahora dice que tiene grupos (“Groups:”), y nos dice qué columna es la que agrupa los datos (“especie”) y cuántos grupos hay (“3”). Cualquier operación que hagamos a continuación del group_by() van a aplicarse para cada grupo.\nPara ver esto en acción, usá summarise() para computar el promedio del largo de la aleta.\n\npinguinos |&gt; \n  group_by(especie) |&gt;   \n  summarise(aleta_promedio = mean(largo_aleta_mm, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  especie aleta_promedio\n  &lt;chr&gt;            &lt;dbl&gt;\n1 Adelia            190.\n2 Barbijo           196.\n3 Papúa             217.\n\n\n¡Tadá! summarise() devuelve una tabla con una columna para la especie y otra nueva, llamada “aleta_promedio” que contiene el promedio de del largo de la aleta para cada grupo.\ngroup_by() permite agrupar en base a múltiples columnas y summarise() permite generar múltiples columnas de resumen. El siguiente código calcula la cantidad de pingüinos por especie y por isla y el promedio de su masa corporal.\n\npinguinos |&gt; \n  group_by(especie, isla) |&gt; \n  summarise(cantidad = n(),\n            promedio_masa_corporal = mean(masa_corporal_g, na.rm = TRUE))\n\n`summarise()` has grouped output by 'especie'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 4\n# Groups:   especie [3]\n  especie isla      cantidad promedio_masa_corporal\n  &lt;chr&gt;   &lt;chr&gt;        &lt;int&gt;                  &lt;dbl&gt;\n1 Adelia  Biscoe          44                  3710.\n2 Adelia  Dream           56                  3688.\n3 Adelia  Torgersen       52                  3706.\n4 Barbijo Dream           68                  3733.\n5 Papúa   Biscoe         124                  5076.\n\n\n\nLa función n() cuenta la cantidad de elementos en cada grupo, en este caso la cantidad de pingüinos por especie e isla. A diferencia de otras funciones que venimos usando no requiere de ningún argumento para funcionar en el contexto de summarise()\n\nEl resultado va a siempre ser una tabla con la misma cantidad de filas que grupos y una cantidad de columnas igual a la cantidad de columnas usadas para agrupar y los estadísticos computados.\n\n¿Cuál te imaginás que va a ser el resultado del siguiente código? ¿Cuántas filas y columnas va a tener? (Tratá de pensarlo antes de correrlo.)\n\npinguinos |&gt; \n   summarise(promedio_pico = mean(largo_pico_mm, na.rm = TRUE))\n\n\nEl combo group_by() |&gt; summarise() se puede resumir en esta figura. Las filas de una tabla se dividen en grupos, y luego cada grupo se “resume” en una fila en función del estadístico usado.\n\n\n4.3.1 reframe() entra a la cancha\nsummarise() funciona re bien hasta que que nos encontramos con la necesidad de hacer cuentas más complejas. Por ejemplo, supongamos que queremos calcular el cuantil 0.25 de la masa corporal porque decidimos que todos los pinguinos con un peso por debajo de ese valor son “pequeños”. Con lo que vimos hasta ahora podemos calcularlo.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  summarise(cuantil_masa = quantile(masa_corporal_g, c(0.25), na.rm = TRUE))\n\n# A tibble: 3 × 2\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Barbijo        3488.\n3 Papúa          4700 \n\n\nPero se vuelve tedioso si queremos otros cuantiles, por ejemplo el 0.75 (porque decidimos los pingüinos con masa mayor a ese valor sn “grandes”). Si intentamos extender el código anterior además del resultado vamos a terminar con un warning enorme.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  summarise(cuantil_masa = quantile(masa_corporal_g, c(0.25, 0.75), na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n`summarise()` has grouped output by 'especie'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 6 × 2\n# Groups:   especie [3]\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Adelia         4000 \n3 Barbijo        3488.\n4 Barbijo        3950 \n5 Papúa          4700 \n6 Papúa          5500 \n\n\nEl problema es que estamos opteniendo 2 valores para cada grupo, es decir el cuantil 0.25 y el 0.75 para cada especie. En estos casos tenemos que usar reframe() que funciona de manera similar a summarise() pero está pensada para estos casos donde calculamos más de un valor por grupo.\n\npinguinos |&gt; \n  group_by(especie) |&gt; \n  reframe(cuantil_masa = quantile(masa_corporal_g, c(0.25, 0.75), na.rm = TRUE))\n\n# A tibble: 6 × 2\n  especie cuantil_masa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Adelia         3350 \n2 Adelia         4000 \n3 Barbijo        3488.\n4 Barbijo        3950 \n5 Papúa          4700 \n6 Papúa          5500",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#creando-nuevas-columnas-con-mutate",
    "href": "03_manipulacion-1.html#creando-nuevas-columnas-con-mutate",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.4 Creando nuevas columnas con mutate()\n",
    "text": "4.4 Creando nuevas columnas con mutate()\n\nTodo esto está bien para hacer cálculos con columnas previamente existentes, pero muchas veces tenés que crear nuevas columnas.\nPodríamos querer expresar la masa corporal de los pingüinos en kilos en vez de gramos.\n\npinguinos |&gt; \n  mutate(masa_corporal_kg = masa_corporal_g/100)\n\n# A tibble: 344 × 9\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 Adelia  Torg…          39.1         18.7            181            3750 macho\n 2 Adelia  Torg…          39.5         17.4            186            3800 hemb…\n 3 Adelia  Torg…          40.3         18              195            3250 hemb…\n 4 Adelia  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 Adelia  Torg…          36.7         19.3            193            3450 hemb…\n 6 Adelia  Torg…          39.3         20.6            190            3650 macho\n 7 Adelia  Torg…          38.9         17.8            181            3625 hemb…\n 8 Adelia  Torg…          39.2         19.6            195            4675 macho\n 9 Adelia  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 Adelia  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 2 more variables: anio &lt;dbl&gt;, masa_corporal_kg &lt;dbl&gt;\n\n\nRecordá que las funciones de dplyr nunca modifican la tabla original. mutate() devolvió una nueva tabla que es igual a la tabla pinguinos pero con la columna “masa_corporal_kg” agregada al final. Si no asignamos este resultado a una variable, no podremos usarlo luego.\nLa función mutate() además de permitir crear nuevas columnas, también permite modificar o actualizar columnas existentes. Para eso, solo es necesario asignarle el nombre de la columa que queremos modificar.\n\npinguinos |&gt; \n  mutate(especie = toupper(especie))\n\n# A tibble: 344 × 8\n   especie isla  largo_pico_mm alto_pico_mm largo_aleta_mm masa_corporal_g sexo \n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;\n 1 ADELIA  Torg…          39.1         18.7            181            3750 macho\n 2 ADELIA  Torg…          39.5         17.4            186            3800 hemb…\n 3 ADELIA  Torg…          40.3         18              195            3250 hemb…\n 4 ADELIA  Torg…          NA           NA               NA              NA &lt;NA&gt; \n 5 ADELIA  Torg…          36.7         19.3            193            3450 hemb…\n 6 ADELIA  Torg…          39.3         20.6            190            3650 macho\n 7 ADELIA  Torg…          38.9         17.8            181            3625 hemb…\n 8 ADELIA  Torg…          39.2         19.6            195            4675 macho\n 9 ADELIA  Torg…          34.1         18.1            193            3475 &lt;NA&gt; \n10 ADELIA  Torg…          42           20.2            190            4250 &lt;NA&gt; \n# ℹ 334 more rows\n# ℹ 1 more variable: anio &lt;dbl&gt;\n\n\n\n¿Te acordás del ejercicio que arrancaste cuando vimos filtros? Es hora de completarlo!\n\nCompletá los ejercicios de este archivo que ya deberías tener en tu proyecto.\nTe vas a encontrar con ejercicios para practicar summarise() y mutate(). De nuevo, en algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nCuando hayas terminado, knitea el archivo para generar un html y ver como queda el resultado.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "03_manipulacion-1.html#ex-exploracion",
    "href": "03_manipulacion-1.html#ex-exploracion",
    "title": "\n4  Manipulación de datos ordenados I\n",
    "section": "\n4.5 Construyendo un paquete de R paso a paso",
    "text": "4.5 Construyendo un paquete de R paso a paso\n\nAhora que ya tenés las herramientas para manipular y transformar datos ordenados, es hora de familiarizarte más con los datos de las estaciones meteorológicas.\nTe proponemos responder a las siguientes preguntas manipulando los datos con los verbos de dplyr que vimos hasta ahora. Pero seguramente necesites nuevas funciones, te iremos dando pistas en el camino.\nPero antes de eso, sería útil tener todos los datos de las estaciones en un solo data.frame. Seguramente los leiste por separado y cada uno tiene un nombre distinto. La función rbind() permite unir data.frames uno debajo del otro. Usá el siguiente código y completalo para generar un data.frame con los datos de todas las estaciones.\nnuevo_nombre &lt;- rbind(___, ____, ____)\nPreguntas\n\n¿Cuántas observaciones de temperatura se hicieron en cada estación?\n¿Cuál es la temperatura mínima registrada y la máxima registrada en cada estación?\n¿Cuál es el promedio de la temperatura de abrigo a 150 cm en cada estación? ¿Y el desvío estandar? Pista: la mayoría de las funciones tienen un argumento para sacar los NA del cálculo, revisá la documentación de mean() y de sd().\n¿Cuál es la proporción de NA en temperatura de abrigo a 150 cm? Pista: podés calcular la proporción como cantidad de NA dividido la cantidad total de observaciones. La función is.na() devuelve TRUE si el valor es un NA, al mismo tiempo TRUE es igual a 1 (así es como R lo interpreta) por lo que sum(is.na(variable)) te va a dar la cantidad de NA en esa variable.\n¿Cuál es el promedio anual de la temperatura de abrigo a 150 cm en cada estación? Pista, podés extraer el año de la variable fecha con anio = year(fecha) y usar esa nueva variable para agrupar los datos.\n¿Cuál es la precipitación acumulada mensual en cada estación? Pista: la precipitación acumulada mensual es la suma de la precipitación en cada mes. En este caso necesitas agrupar los datos por año y mes, una posibilidad es usar floor_date(fecha, \"month\").",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulación de datos ordenados I</span>"
    ]
  },
  {
    "objectID": "04_git-1.html",
    "href": "04_git-1.html",
    "title": "5  git para trabajar individualmente",
    "section": "",
    "text": "5.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#objetivos-de-aprendizaje",
    "href": "04_git-1.html#objetivos-de-aprendizaje",
    "title": "5  git para trabajar individualmente",
    "section": "",
    "text": "Identificar por qué el control de versiones, específicamente Git, es importante para el desarrollo de software y análisis de datos.\nDiferenciar métodos para trabajar con Git y R: integración con RStudio.\nAplicar el proceso de modificación-add-commit como el flujo de trabajo de Git para el seguimiento de los cambios y ver el historial de commits de un repositorio.\nPublicar repositorios en GitHub y coordinar versiones remotas y locales.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#por-qué-git",
    "href": "04_git-1.html#por-qué-git",
    "title": "5  git para trabajar individualmente",
    "section": "5.2 ¿Por qué git?",
    "text": "5.2 ¿Por qué git?\n¿Tenés algo así en tu computadora?\n/home/pao/Documents/Clases/progrmacion\n├── script.R\n├── tp.Rmd\n├── tp_corregido.Rmd\n├── tp_corregido2.Rmd\n├── tp_final.Rmd\n├── tp_finalfinal.Rmd\n├── este_es_el_final.Rmd\n├── juro_que_esta_es_la_ultima_version_del_tp.Rmd\n└── FINAL.Rmd\nProbablemente todos lo tenemos, o tuvimos algo así en algún momento, porque necesitamos guardar nuestro trabajo pero seguir teniendo acceso a versiones anteriores. Existe una solución para esto. Los sistemas de control de versiones gestionan la evolución y los cambios de un conjunto de archivos que llamaremos repositorio. Si alguna vez revisaste el historial de un archivo de Google Docs, el control de versiones es similar pero de una forma muy controlada. Git es un sistema de control de versiones muy popular, pero hay otros.\nSi trabajas de manera individual, git es genial para hacer un seguimiento de los cambios y recuperar versiones anteriores de tus archivos. También podés utilizar un repositorio remoto (que veremos más adelante) para tener una copia de seguridad y compartir tu trabajo.\nSi trabajas en equipo, podés aprovechar todo lo anterior y utilizar también el control de versiones como herramienta para colaborar y organizar las distintas versiones de un mismo archivo presentes en las múltiples computadoras que vos y las otras personas usen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#pero-qué-entendemos-por-control-de-versiones",
    "href": "04_git-1.html#pero-qué-entendemos-por-control-de-versiones",
    "title": "5  git para trabajar individualmente",
    "section": "5.3 Pero, ¿qué entendemos por control de versiones?",
    "text": "5.3 Pero, ¿qué entendemos por control de versiones?\nImaginemos que tenemos un repositorio funcionando (más adelante veremos cómo crear uno). Cuando creas un nuevo archivo como parte del repositorio (o repo), ese archivo inicialmente no es trackeado o no está versionado. Esto significa que git ignorará el archivo y cualquier cambio que hayas hecho hasta que lo agregues al repositorio (add en inglés) y empieces a registrar los cambios que hagas en el contenido. En ese momento el archivo está en el area staging (que podemos imagina como una sala de espera de git) y está listo para entrar en el repositorio. Para eso hay que confirmar o registrar (commit en inglés) esa versión del archivo en el repositorio. Este flujo de trabajo modify --&gt; add --&gt; commit se repetirá cada vez que quieras guardar una versión del archivo.\n\nNo recomendamos hacer un commit cada vez que guardes el archivo o cambies una coma, y tampoco es buena idea hacer un commit con mil millones de cambios. Con la práctica y dependiendo de cómo trabajes, encontrarás un punto medio cómodo.\n\n\n\n\nLa figura muestra el ciclo de cambios en un archivo: versionado o sin versional. Cuando es versionado y forma parte del repositorio, las acciones son add, commit, y modificar. Con la acción add, el archivo se “prepara”; con la acción de commit, el archivo se “guarda” en el repositorio. Este ciclo se repite cada vez que se modifica el archivo.\n\n\nMencionamos las acciones add y commit que son los nombres de dos comandos de git. Si tenes experiencia trabajando con la terminal podés utilizar git desde ahí, pero los mismos comandos pueden ejecutarse desde una GUI como GitHub Desktop o GitKraken. Durante este curso utilizaremos RStudio.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#ya-mencionamos-repositorio-remoto",
    "href": "04_git-1.html#ya-mencionamos-repositorio-remoto",
    "title": "5  git para trabajar individualmente",
    "section": "5.4 ¿Ya mencionamos “repositorio remoto”?",
    "text": "5.4 ¿Ya mencionamos “repositorio remoto”?\nAntes revisamos el flujo de trabajo local. El repositorio (una carpeta oculta llamada .git) vive en tu computadora y con eso ya estas usando control de versiones. Pero, también podrías conectar el repositorio local con un repositorio remoto. En este curso vamos a utilizar GitHub para alojar repositorios remotos, pero hay otras opciones que podrías explorar, como GitLab.\nSi usas un repositorio remoto, tendrás que agregar un paso más al flujo de trabajo local (modify --&gt; add --&gt; commit) para asegurarte que la copia del repositorio en tu computadora es la misma que la copia en GitHub y vise versa.\nLuego, otra persona de tu equipo hace un cambio en un archivo en su repositorio local y lo sube al repositorio remoto. Ahora, tu repositorio local está “desactualizado” y necesitas descargar esos nuevos commits del repositorio remoto a tu computadora. Necesitas hacer pull.\nSi luego, otra persona de tu equipo hace un cambio en un archivo en su repositorio local y lo sube al repositorio remoto. Ahora, tu repositorio local está “desactualizado” respecto del repositorio remoto. Necesitas descargar esos nuevos commits del repositorio remoto a tu computadora. Necesitas hacer pull.\n\n\n\nModelo conceptual de un flujo de trabajo utilizando proyectos RStudio y git. Los archivos se añaden al área de preparación y luego se envían al repositorio local. Puedes enviar commits al repositorio remoto y bajar nuevos commits a tu computadora.\n\n\nHerramientas como GitHub también incluyen funciones que te ayudan a colaborar y gestionar repositorios. Por ejemplo, puedes modificar archivos y hacer commits con esos cambios utilizando la interfaz web.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#configuración-inicial",
    "href": "04_git-1.html#configuración-inicial",
    "title": "5  git para trabajar individualmente",
    "section": "5.5 Configuración inicial",
    "text": "5.5 Configuración inicial\nAntes de crear tu primer repositorio es importante revisar que git esté configurado correctamente en tu computadora y que tengas permisos para modificar cosas en GitHub. Si seguiste las instrucciones instrucciones previas al curso deberías tener todo listo, pero podemos revisar el estado de situación con usethis::git_sitrep() para comprobarlo.\n&gt; usethis::git_sitrep()\n\n── Git global (user) \n• Name: \"Pao Corrales\"\n• Email: \"micorreo@gmail.com\"\n• Global (user-level) gitignore file: ~/.gitignore\n• Vaccinated: TRUE\n• Default Git protocol: \"https\"\n• Default initial branch name: \"main\"\n\n── GitHub user \n• Default GitHub host: \"https://github.com\"\n• Personal access token for \"https://github.com\": &lt;discovered&gt;\n• GitHub user: \"paocorrales\"\n• Token scopes: \"gist\", \"repo\", \"user\", and \"workflow\"\n• Email(s): \"micorreo@gmail.com (primary)\", \"paocorrales@users.noreply.github.com\", and\n  \"otro correo@gmail.com\"\nℹ No active usethis project.\nRevisá que la información sea correcta y que Personal access token for \"https://github.com\": sea igual a &lt;discovered&gt;. Eso te garantizará que puedas trabajar con git y GitHub. Si vez alguna diferencia, es útil revisar las instrucciones de instalación en el anexo A Preparando el entorno de trabajo.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#creando-un-nuevo-repositorio",
    "href": "04_git-1.html#creando-un-nuevo-repositorio",
    "title": "5  git para trabajar individualmente",
    "section": "5.6 Creando un nuevo repositorio",
    "text": "5.6 Creando un nuevo repositorio\nHay muchas formas de iniciar un nuevo repositorio, localmente en tu computadora utilizando la terminal, desde GitHub (o sus amigos) ¡o desde RStudio!. Aca te mostraremos cómo crear un repositorio desde GitHub, asociarlo a un proyecto de RStudio y trabajar con él. Pero tené en cuenta que hay muchas otras formas de trabajar con git.\n\n1. Creá un repositorio online.\n\nEntrá en github.com e inicia sesión.\nEn la esquina superior derecha, hacé click en el botón “+” y luego en “New repository”.\n\nA continuación completá la información del repositorio:\n\nRepository template: No template.\nRepository name: como quieras llamar a tu nuevo proyecto.\nDescription: Una descripción breve del proyecto. Escribila para los humanos.\nVisibilidad: Public.\nInitialize this repository with: nada (podemos configurarlo todo desde R).\n\nAntes de volver a RStudio, copia la url del repositorio. Por ejemplo https://github.com/paocorrales/myrepo.git\nYa tenés tu repositorio local!\n\n\n2. En RStudio, inicia un nuevo Proyecto:\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio” pegá la URL de tu nuevo repositorio de GitHub, tiene que tener esta pinta: https://github.com/paocorrales/myrepo.git.\nElejí la carpeta en tu disco donde querés crear el proyecto.\nElejí “Open in new sesion”.\nY hacé clic en “Create project”.\n\n\nLa nueva carpeta en tu computadora será un repositorio git, vinculado a un repositorio remoto de GitHub y un proyecto de RStudio al mismo tiempo. Este flujo de trabajo también se asegura de que toda la configuración entre los repositorios local y remoto se realice correctamente.\nTambién agrega un archivo llamado .gitignore que incluye una lista de archivos que no queremos sumar al repositorio (por ejemplo .Rhistory).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#cambios-locales",
    "href": "04_git-1.html#cambios-locales",
    "title": "5  git para trabajar individualmente",
    "section": "5.7 Cambios locales",
    "text": "5.7 Cambios locales\nEs hora de poner en práctica algunas de las cosas de las que hemos estado hablando.\n\nAdd, commit\n\nCreá un nuevo archivo RMarkdown y guardalo.\nAgregalo al área de preparación con add y luego hace un commit. ¡Vas a tener que pensar un mensaje descriptivo!\nHace un cambio en el archivo, puede ser cualquier cosa. Guardalo.\nRepetí el paso 2.\n\n\n\n\nPanel Git con 3 archivos sin seguimiento.\n\n\n\n\n\nPanel Git con 3 archivos con seguimiento añadidos al área de preparación.\n\n\n\n\n\nInterfaz RStudio para ver las diferencias entre archivos, escribir el mensaje para el commit y enviarlo al repositorio remoto.\n\n\n\nSi todo salió bien, empezaste a rastrear archivos, hiciste cambios y commits para guardar esa versión en el repositorio local. Puede que veas un mensaje en la pestaña de git diciendo que el repositorio local “is ahead of ’origin/master` by 2 commits”. No verás ningún cambio en GitHub hasta que hagas push y envíes esos commits al repositorio remoto. Podés hacer esto al final del día si preferis, pero si trabajas con otras personas puede ser una buena idea hacer push luego de cada commit.\n\n¡Push!\n\nAhora, hacé push para enviar los commits al repositorio remoto utilizando el botón con la flecha verde apuntando hacia arriba.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#cambios-remotos",
    "href": "04_git-1.html#cambios-remotos",
    "title": "5  git para trabajar individualmente",
    "section": "5.8 Cambios remotos",
    "text": "5.8 Cambios remotos\nVolvamos a GitHub. Si actualizas la página, ahora verás los archivos que acabas sumar al repositorio o modificar. Hagamos click en “Commits” para ver la historia del repositorio. Desde esta página, podés explorar el repositorio en el “estado” en el que estaba con cada commit y ver las diferencias entre las distintas versiones.\nAhora, podemos intentar hacer cambios aquí.\n\nCrear un README\n\nEn la página principal, hacé click en el botón verde que dice “Add a README”.\nAgregá algo en el archivo. Los README suelen estar escritos en Markdown y contienen información sobre el repositorio.\nAl final de la página añadí un mensaje y hacé click en “Confirm changes…”.\nVolvé a la página principal para ver el README.\n\n\nEl nuevo archivo y los cambios que hagas en GitHub sólo estarán en el repositorio remoto hasta que hagas un pull en el repositorio local. Si realizas cambios en el repositorio local mientras no está actualizado, podés encontrarte con conflictos cuando intentes unir las 2 versiones, lo que suele generar dolores de cabeza. Esto ocurre cuando la versión de un archivo en el repositorio local no es compatible con su versión en el repositorio remoto. En esos casos, git no puede decidir qué versión es la correcta y tenés que hacerlo vos.\nPara evitar este problema (lo más posible), tenes que hacer un pull antes de empezar a hacer cualquier otra cosa. La mayoría de las veces RStudio mostrará el mensaje “Already up to date”, pero es bueno hacerlo un hábito.\n\nPull desde GitHub\n\nVolvé a RStudio.\nRevisá panel de Git.\nHacé click en la flecha azul que dice “Pull”.\nRevisá el archivo README en la pestaña Archivos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "04_git-1.html#anatomía-de-un-repositorio-de-github",
    "href": "04_git-1.html#anatomía-de-un-repositorio-de-github",
    "title": "5  git para trabajar individualmente",
    "section": "5.9 Anatomía de un repositorio de GitHub",
    "text": "5.9 Anatomía de un repositorio de GitHub\n\nArchivos README. Utilizá un README.md para explicar de que se trata es tu proyecto y cómo utilizarlo. README.md es el archivo que se muestra automáticamente cuando abrís un repositorio de GitHub.\nLicencia. La licencia le indica a las personas cómo puede utilizar el contenido de tu repositorio. Generalmente, utilizamos licencias permisivas para que las personas pueda utilizar los materiales de cualquier manera. Algunos ejemplos son la Licencia MIT o Apache. Podés revisar algunos recursos extra:\n\nElejí una licencia para proyectos de código.\nLicencias de software en lenguaje sencillo: explica la jerga legal de las licencias en términos sencillos\n\nGuía para colaborar. Un archivo llamado CONTRIBUTING.md que incluye las instrucciones que personas que quieren conlaborar en tu proyecto sepan lo que deben hacer si quieren ayudarte.\nCódigo de conducta. Los buenos proyectos tienen códigos de conducta para garantizar un ambiente amigable donde las personas pueden colaborar. Github tiene atajos para agregar Código de Conducta facilmente.\nIssues. Te permiten gestionar el proyecto, discutir problemas y mejoras con otras personas.\n\n\nPara practicar git y de paso lo que estuvimos viendo sobre manipulación de datos vamos a usar GitHub Classroom.\n¿Cómo funciona?\nPreparamos repositorios con distintos ejercicios para que resuelvan. Cada persona tendrá su repositorio para trabajar de manera individual, aunque siempre pueden resolver los ejercicios en grupos (pequeños!, 2 o 3 personas)\nEn el campus encontrarás las instrucciones para acceder a tu repositorio.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>git para trabajar individualmente</span>"
    ]
  },
  {
    "objectID": "05_graficos.html",
    "href": "05_graficos.html",
    "title": "\n6  Graficado datos\n",
    "section": "",
    "text": "6.0.1 Primera capa: el área del gráfico\nVisualizar datos es útil para identificar a relación entre distintas variables pero también para comunicar el análisis de los datos y resultados. El paquete ggplot2 permite generar gráficos de gran calidad en pocos pasos. Cualquier gráfico de ggplot tendrá como mínimo 3 componentes: los datos, un sistema de coordenadas y una geometría (la representación visual de los datos) y se irá construyendo por capas.\nCómo siempre será necesario cargar los paquetes que vamos a usar y ya que estamos los datos con los que venimos trabajando:\nlibrary(ggplot2)\npaises &lt;- datos::paises\n\nstr(paises)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ pais             : Factor w/ 142 levels \"Afganistán\",\"Albania\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continente       : Factor w/ 5 levels \"África\",\"Américas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ anio             : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ esperanza_de_vida: num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ poblacion        : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ pib_per_capita   : num [1:1704] 779 821 853 836 740 ...\nLa función principal de ggplot2 es justamente ggplot() que nos permite iniciar el gráfico y además definir las características globales. El primer argumento de esta función serán los datos que queremos visualizar, siempre en un data.frame. En este caso usamos paises.\nEl segundo argumento se llama mapping justamente porque mapea o dibuja los ejes del gráfico y siempre va acompañado de la función aes(). La función aes() recibe las propiedades estéticas del gráfico (o aesthetic en inglés) a partir de las variables (o columnas) del data.frame que estamos usando. En este caso le indicamos que en el eje x querremos graficar la variable pib_per_capita y en eje y la variable esperanza_de_vida.\nPero esta sola función no es suficiente, solo genera la primera capa: el área del gráfico.\nggplot(data = paises, mapping = aes(x = pib_per_capita, y = esperanza_de_vida))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#gráficos-de-frecuencias",
    "href": "05_graficos.html#gráficos-de-frecuencias",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.1 Gráficos de frecuencias",
    "text": "6.1 Gráficos de frecuencias\nEste es un gráfico de barras construido usando la función geom_bar(). En el eje x muestra el corte de los diamantes y en el eje y la cantidad (count en inglés) de diamantes en cada categoría. Pero diamantes no tiene una variable que se llame count y tampoco la generamos nosotros. ¡Es calculada internamente por ggplot2!\n\nggplot(data = diamantes, aes(x = corte)) +\n  geom_bar()\n\n\n\n\n\n\n\nCómo el gráfico de barras, también podemos graficar histogramas con geom_histogram() y polígonos de frecuencia con geom_density() para visualizar la cantidad de observaciones que caen en cada categoría (si la variable es discreta como el caso del corte de los diamantes) o rango de valores (para variables continuas).\nUn ejemplo de variable continua es el precio de los diamantes, veamos como se ve un histograma y de paso le cambiamos el color a las barras, pero ojo, solo al borde.\n\nggplot(diamantes, aes(precio)) +\n  geom_histogram(fill = \"darkorange\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n¿Notaste el mensaje que devuelve el gráfico?\n`stat_bin() using bins = 30. Pick better value with binwidth.`\nEsta geometría tiene dos argumentos importantes bins y binwidth. Cambiá el valor de alguno de los dos argumentos y volvé a generar el gráfico, ¿que rol juegan los argumentos?\nTambién podés revisar la documentación.\n\nAdemás de contar la cantidad de elementos, ggplot2 puede calcular muchas otras transformaciones sobre los datos. Por ejemplo si quisiéramos el porcentaje o la proporción que le corresponde a cada categoría de corte respecto del total podemos hacerlo mapeando esa transformación prop al eje y con la función after_stat().\n\nggplot(data = diamantes, aes(x = corte)) +\n  geom_bar(aes(y = after_stat(prop), group = 1))\n\n\n\n\n\n\n\nFijate que la variable prop no es una columna de diamantes sino que es el nombre de una variable computada por geom_bar(), por eso hay que rodearla de la función stat(). El nombre de las variables computadas por cada geoms está en su documentación (abajo de todo, antes de los ejemplos).\nAhora podríamos decir que el 40% de los diamantes en la base de datos tienen un corte ideal. Además de la función after_stat() agregamos group = 1 y esto no fue sin querer. Probá correr el gráfico sin ese argumento.\nAl incluir group = 1, ggplot2 junta todas las observaciones en un único grupo (con el valor 1) y calcula la proporción o el porcentaje que representa cada corte respecto del total de diamantes. Si no incluimos eso, ggplot2 asumirá que cada categoría de corte es un grupo independiente y el cálculo del porcentaje también lo hará por separado.\n\nLas geometrías geom_col() y geom_bar() tienen un argumento llamado position que afecta como se organizan las barras particularmente cuando mapeamos una tercer variable al relleno. Por ejemplo:\n\nggplot(data = diamantes) +\n  geom_bar(aes(x = corte, fill = claridad))\n\n\n\n\n\n\n\n\nRevisá la documentación de estas geometrías e identificá las distintas opciones que puede tomar el argumento position.\nProbá cada uno y comparalos para ver las diferencias.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#gráficos-de-caja",
    "href": "05_graficos.html#gráficos-de-caja",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.2 Gráficos de caja",
    "text": "6.2 Gráficos de caja\nLos diagramas de caja, mejor conocidos como boxplots calculan un resumen robusto de la distribución y luego muestran una caja con formato especial.\nLa línea central de la caja corresponde a la mediana (el valor que toma el dato central) y los extremos de la caja son los cuartiles 1 y 3, definiendo así el rango intercuartil (IQR). Los extremos están definidos como el valor observado que no esté más lejos de 1.5*IQR de la mediana y los puntos son los las observaciones que se escapan de ese rango, que pueden ser considerados outliers o valores extremos.\n\nggplot(diamantes, aes(claridad, precio)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nLos boxplot dan muchísima información sobre los datos pero al mismo tiempo esconden la cantidad de observaciones que se usaron para generarlos y en particular cual es la frecuencia a lo largo del eje y. Por esta razón también existen geom_violin() y geom_jitter().\n\n\nVolvé a graficar la distribución del precio para cada tipo de claridad pero ahora usando geom_violin() y geom_jitter().\n¿Qué ventajas y desventajas encuentran respecto de geom_boxplot()?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCuando nuestra base de datos es muy grande corremos el riesgo de que los elementos del gráfico estén tan juntos que se solapen y no se vean. Esto se conoce como overplotting. La base de datos diamantes tiene 53940 observaciones y al graficar un punto por cada una, aún si están separados por la claridad, quedan superpuestos.\nPara resolver este problema se suele modificar la estética de los elementos, cambiando el tamaño o size para que ocupen menos lugar y se vean mejor, cambiando la forma o shape por alguna que no tenga relleno y permita ver los elementos que hay atrás o modificando la transparencia o alpha por la misma razón. En bases de datos tan grandes como la de diamantes, muchas veces hay que utilizar varios de estos recursos.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#graficando-en-múltiples-paneles",
    "href": "05_graficos.html#graficando-en-múltiples-paneles",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.3 Graficando en múltiples paneles",
    "text": "6.3 Graficando en múltiples paneles\nVimos que es posible graficar más de dos variables en un gráfico mapeando una variable al color o por ejemplo el tipo de línea o linetype\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\nEn este caso no solo visualizamos la relación entre el precio y el quilate del diamante, también podemos ver que rol juega el color. También podríamos haber intentando resolver el problema generando un gráfico por cada color filtrando las observaciones correspondientes.\n\ndiamantes %&gt;% \n  filter(color == \"D\") %&gt;% \n  ggplot(aes(quilate, precio)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\nPero sería muchísimo trabajo si tenemos que hacer esto para cada una de las 7 categorías de color. La buena noticia es que ggplot2 tiene un par de funciones justo para resolver este problema:\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color)) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\nEsta nueva capa con facet_wrap() divide al gráfico inicial en 7 paneles o facets, uno por cada color. Esta función requiere saber que variable será la responsable de separar los paneles y para eso se usa la notación de funciones de R: ~color. Esto se lee como generar paneles “en función del color”.\n¿Y si quisiéramos generar paneles a partir de 2 variables? Para eso existe facet_grid(). En este gráfico generamos paneles viendo la “relación entre el corte y el color” y por ejemplo en el primer panel arriba a la izquierda podremos observar los diamantes que son al mismo tiempo de color D y corte Regular. En este caso mapear la variable color al color de los diamantes no parece ser necesario ya que cada columna ya nos permite identificar eso, sin embargo en algunos casos ayuda a leer el gráfico más rápido.\n\nggplot(diamantes, aes(quilate, precio)) +\n  geom_point(aes(color = color)) +\n  facet_grid(corte~color)\n\n\n\n\n\n\n\n\nGenerá boxplots para analizar como se comporta el precio según la claridad para cada tipo de corte como se ve acá.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "05_graficos.html#ex-graficos",
    "href": "05_graficos.html#ex-graficos",
    "title": "\n6  Graficado datos\n",
    "section": "\n6.4 Construyendo un paquete de R paso a paso",
    "text": "6.4 Construyendo un paquete de R paso a paso\n\nSigamos analizando los datos de estaciones meteorológicas.\n\nGraficá la temperatura de abrico para la estación NH0437 (tendrías que filtrar los datos para quedarte solo con esta estación). Sumá una regresión linea, ¿se mentiene constante la temperatura media con el tiempo o cambia?\n\n\nCalculá el promedio mensual de la temperatura de abrigo para cada estación y gráfica el resultado. El gráfico tendría que tener más o menos esta pinta:\n\n\n\n\n\n\n\n\n\n\n¿Cuál es la relación entre la temperatura de abrigo y la humedad? Hacé un gráfico de puntos que muestre la relación, podés sumar un suavisado (opcional). Para la humedad utilizá la varable humedad_media_8_14_20.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Graficado datos</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html",
    "href": "06_manipulacion-2.html",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "",
    "text": "7.1 De ancho a largo con pivot_longer()\nVenimos hablando y trabajando con datos ordenados, o en formato largo, donde:\nPodríamos organizar la informaciuón es un formato “ancho” donde:\nUna tabla en formato largo va a tener una cierta cantidad de columnas que cumplen el rol de identificadores  y cuya combinación identifican una única observación y una única columna con el valor de la observación. En el ejemplo de arriba, pais y anio son las columnas identificadoras y casos es la columna que contiene el valor de las observaciones.\nEn una tabla ancha, cada observación única se identifica a partir de la intersección de filas y columnas. En el ejemplo, los países están en las filas y los años en las columnas.\nEn general, el formato ancho es más compacto y legible por humanos mientras que el largo es más fácil de manejar con la computadora. Si te fijás en las tablas de arriba, es más fácil comparar los valores entre países y entre años en la tabla ancha. Pero el nombre de las columnas (“1999”, “2000”) en realidad ¡son datos! Además este formato se empieza a complicar en cuanto hay más de dos identificadores.\nUn mismo set de datos puede ser representado de forma completamente “larga”, completamente “ancha” o –lo que es más común– en un formato intermedio pero no existe una forma “correcta” de organizar los datos; cada una tiene sus ventajas y desventajas. Por esto es que es muy normal que durante un análisis los datos vayan y vuelvan entre distintos formatos dependiendo de los métodos estadísticos que se le aplican. Entonces, aprender a transformar datos anchos en largos y viceversa es un habilidad muy útil.\nEn esta sección vamos a usar el paquete tidyr para manipular datos. Si no lo tenés instalado, instalalo con el comando:\n(como siempre, recordá que esto hay que hacerlo una única vez en la consola)\nY luego cargá tidyr y dplyr con:\nAntes, usamos el set de datos de paises que viene en el paquete datos. Vamos a usar los datos originales que tienen un formato ancho.\npaises_ancho &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/paises_ancho.csv\")\n\nRows: 142 Columns: 38\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): pais, continente\ndbl (36): esperanza_de_vida-1952, esperanza_de_vida-1957, esperanza_de_vida-...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npaises_ancho\n\n# A tibble: 142 × 38\n   pais       continente `esperanza_de_vida-1952` `esperanza_de_vida-1957`\n   &lt;chr&gt;      &lt;chr&gt;                         &lt;dbl&gt;                    &lt;dbl&gt;\n 1 Afganistán Asia                           28.8                     30.3\n 2 Albania    Europa                         55.2                     59.3\n 3 Argelia    África                         43.1                     45.7\n 4 Angola     África                         30.0                     32.0\n 5 Argentina  Américas                       62.5                     64.4\n 6 Australia  Oceanía                        69.1                     70.3\n 7 Austria    Europa                         66.8                     67.5\n 8 Baréin     Asia                           50.9                     53.8\n 9 Bangladesh Asia                           37.5                     39.3\n10 Bélgica    Europa                         68                       69.2\n# ℹ 132 more rows\n# ℹ 34 more variables: `esperanza_de_vida-1962` &lt;dbl&gt;,\n#   `esperanza_de_vida-1967` &lt;dbl&gt;, `esperanza_de_vida-1972` &lt;dbl&gt;,\n#   `esperanza_de_vida-1977` &lt;dbl&gt;, `esperanza_de_vida-1982` &lt;dbl&gt;,\n#   `esperanza_de_vida-1987` &lt;dbl&gt;, `esperanza_de_vida-1992` &lt;dbl&gt;,\n#   `esperanza_de_vida-1997` &lt;dbl&gt;, `esperanza_de_vida-2002` &lt;dbl&gt;,\n#   `esperanza_de_vida-2007` &lt;dbl&gt;, `poblacion-1952` &lt;dbl&gt;, …\nEsta tabla, increíblemente ancha, es muy difícil de manejar. Por ejemplo, es imposible hacer una serie de tiempo de una variable, o calcular el promedio por variable y país; ni hablar de calcular una regresión lineal.\nPara convertirlo en una tabla más larga, se usa pivot_longer() (“longer” es “más largo” en inglés):\npaises_largo &lt;- pivot_longer(paises_ancho,\n                             cols = c(starts_with('pob'), \n                                      starts_with('esperanza'), \n                                      starts_with('pib_per')),\n                             names_to = \"variable_anio\", \n                             values_to = \"valor\"\n)\npaises_largo\n\n# A tibble: 5,112 × 4\n   pais       continente variable_anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt;\n 1 Afganistán Asia       poblacion-1952  8425333\n 2 Afganistán Asia       poblacion-1957  9240934\n 3 Afganistán Asia       poblacion-1962 10267083\n 4 Afganistán Asia       poblacion-1967 11537966\n 5 Afganistán Asia       poblacion-1972 13079460\n 6 Afganistán Asia       poblacion-1977 14880372\n 7 Afganistán Asia       poblacion-1982 12881816\n 8 Afganistán Asia       poblacion-1987 13867957\n 9 Afganistán Asia       poblacion-1992 16317921\n10 Afganistán Asia       poblacion-1997 22227415\n# ℹ 5,102 more rows\nEl primer argumento depivot_longer() es la tabla que va a modificar: paises_ancho. El segundo argumento se llama cols y es un vector con las columnas que tienen los valores a “alargar”. Podría ser un vector escrito a mano (algo como c(\"pib_per_capita-1952\", \"pib_per_capita-1957\"...)) pero con más de 30 columnas, escribir todo eso sería tedioso y probablemente estaría lleno de errores. Por eso tidyr provee funciones de ayuda para seleccionar columnas en base a patrones. El código de arriba usa starts_with() que, como su nombre en inglés lo indica, selecciona las columnas que empiezan con una determinada cadena de caracteres. El vector c(starts_with('pob'), starts_with('esperanza'), starts_with('pib_per')) le dice a pivot_longer() que seleccione las columnas que empieza con “pob”, las que empiezan con “esperanza” y las que empiezan con “pib_per”.\nEl tercer y cuarto argumento son los nombres de las columnas de “nombre” y de “valor” que va a tener la nueva tabla. Como la nueva columna de identificación tiene los datos de la variable y el año a medir, “variable_anio” es un buen nombre. Y la columna de valor va a tener… bueno, el valor.\nTomate un momento para visualizar lo que acaba de pasar. La tabla ancha tenía un montón de columnas con distintos datos. Ahora estos datos están uno arriba de otro en la columna “valor”, pero para identificar el nombre de la columna de la cual vinieron, se agrega la columna “variable_anio”.\nLa columna variable_anio todavía no es muy útil porque contiene 2 datos, la variable (población, expectativa de vida o PBI per cápita) y el año. Sería mejor separar esta información en dos columnas llamadas “variable” y “anio”. Para eso está la función separate().\npaises_largo &lt;- separate_wider_delim(paises_largo, \n         col = variable_anio, \n         delim = \"-\",\n         names = c(\"variable\", \"anio\"))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable  anio     valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion 1952   8425333\n 2 Afganistán Asia       poblacion 1957   9240934\n 3 Afganistán Asia       poblacion 1962  10267083\n 4 Afganistán Asia       poblacion 1967  11537966\n 5 Afganistán Asia       poblacion 1972  13079460\n 6 Afganistán Asia       poblacion 1977  14880372\n 7 Afganistán Asia       poblacion 1982  12881816\n 8 Afganistán Asia       poblacion 1987  13867957\n 9 Afganistán Asia       poblacion 1992  16317921\n10 Afganistán Asia       poblacion 1997  22227415\n# ℹ 5,102 more rows\nEl primer argumento, como siempre, es la tabla a procesar. El segundo, col, es la columna a separar en dos (o más) columnas nuevas. El segundo argumento indica cómo se separan los elementos, en este caso con guíon “-”. El tercero, names es el nombre de las nuevas columnas que separate_wider_delim() va a crear.\nY ya casi. Pero fijate que debajo de la columna anio dice &lt;chr&gt;; eso significa que el tipo de la columna es caracter, pero los años son números. Usando mutate() podemos convertir la columna anio a entero usando as.integer():\npaises_largo &lt;- mutate(paises_largo, \n                       anio = as.integer(anio))\npaises_largo\n\n# A tibble: 5,112 × 5\n   pais       continente variable   anio    valor\n   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;\n 1 Afganistán Asia       poblacion  1952  8425333\n 2 Afganistán Asia       poblacion  1957  9240934\n 3 Afganistán Asia       poblacion  1962 10267083\n 4 Afganistán Asia       poblacion  1967 11537966\n 5 Afganistán Asia       poblacion  1972 13079460\n 6 Afganistán Asia       poblacion  1977 14880372\n 7 Afganistán Asia       poblacion  1982 12881816\n 8 Afganistán Asia       poblacion  1987 13867957\n 9 Afganistán Asia       poblacion  1992 16317921\n10 Afganistán Asia       poblacion  1997 22227415\n# ℹ 5,102 more rows",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#de-ancho-a-largo-con-pivot_longer",
    "href": "06_manipulacion-2.html#de-ancho-a-largo-con-pivot_longer",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "",
    "text": "¿Notaste que en el código anterior no usaste library(readr) para cargar el paquete y luego leer? Con la notación paquete::funcion() podés acceder a las funciones de un paquete sin tener que cargarlo. Es una buena forma de no tener que cargar un montón de paquetes innecesarios si vas a correr una única función de un paquete pocas veces.\n\n\n\n\n\n\nEstas funciones accesorias para seleccionar muchas funciones se llaman “tidyselect”. Si querés leer más detalles de las distintas formas que podés seleccionar variables leé la documentación usando ?tidyselect::language.\n\n\n\n\n\nProceso de largo a ancho\n\n\n\n\n\n\n\nJuntá todos los pasos anteriores en una sola cadena de operaciones usando |&gt;.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#de-largo-a-ancho-con-pivot_wider",
    "href": "06_manipulacion-2.html#de-largo-a-ancho-con-pivot_wider",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "\n7.2 De largo a ancho con pivot_wider()\n",
    "text": "7.2 De largo a ancho con pivot_wider()\n\nAhora la variable paises_largo está en el formato más largo posible. Tiene 5 columnas, de las cuales sólo una es la columnas con valores. Pero con los datos así no podrías hacer un gráfico de puntos que muestre la relación entre el PBI per cápita y la expectativa de vida como en la sección de gráficos. Fijate que los valores de la columna valor no tienen todos las mismas unidades, por lo que operar con ese vector podría dar resultados sin sentido. Muchas veces es conveniente y natural tener los datos en un formato intermedio en donde hay múltiples columnas con los valores de distintas variables observadas.\nPasa “ensanchar” una tabla está la función pivot_wider() (“wider” es “más ancha” en inglés) y el código para conseguir este formato intermedio es:\n\npaises_medio &lt;- pivot_wider(paises_largo, names_from = variable, values_from = valor)\npaises_medio\n\n# A tibble: 1,704 × 6\n   pais       continente  anio poblacion esperanza_de_vida pib_per_capita\n   &lt;chr&gt;      &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt;             &lt;dbl&gt;          &lt;dbl&gt;\n 1 Afganistán Asia        1952   8425333              28.8           779.\n 2 Afganistán Asia        1957   9240934              30.3           821.\n 3 Afganistán Asia        1962  10267083              32.0           853.\n 4 Afganistán Asia        1967  11537966              34.0           836.\n 5 Afganistán Asia        1972  13079460              36.1           740.\n 6 Afganistán Asia        1977  14880372              38.4           786.\n 7 Afganistán Asia        1982  12881816              39.9           978.\n 8 Afganistán Asia        1987  13867957              40.8           852.\n 9 Afganistán Asia        1992  16317921              41.7           649.\n10 Afganistán Asia        1997  22227415              41.8           635.\n# ℹ 1,694 more rows\n\n\nNuevamente el primer argumento es la tabla original. El segundo, names_from es la columna cuyos valores únicos van a convertirse en nuevas columnas. La columna variable tiene los valores \"población\", \"esperanza_de_vida\" y \"pib_per_capita\" y entonces la tabla nueva tendrá tres columnas con esos nombres. El tercer argumento, values_from, es la columna de la cual sacar los valores.\nPara volver al formato más ancho, basta con agregar más columnas en el argumento names_from:\n\npivot_wider(paises_largo, \n            names_from = c(variable, anio), \n            names_sep = \"-\",\n            values_from = valor)\n\n# A tibble: 142 × 38\n   pais       continente `poblacion-1952` `poblacion-1957` `poblacion-1962`\n   &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;\n 1 Afganistán Asia                8425333          9240934         10267083\n 2 Albania    Europa              1282697          1476505          1728137\n 3 Argelia    África              9279525         10270856         11000948\n 4 Angola     África              4232095          4561361          4826015\n 5 Argentina  Américas           17876956         19610538         21283783\n 6 Australia  Oceanía             8691212          9712569         10794968\n 7 Austria    Europa              6927772          6965860          7129864\n 8 Baréin     Asia                 120447           138655           171863\n 9 Bangladesh Asia               46886859         51365468         56839289\n10 Bélgica    Europa              8730405          8989111          9218400\n# ℹ 132 more rows\n# ℹ 33 more variables: `poblacion-1967` &lt;dbl&gt;, `poblacion-1972` &lt;dbl&gt;,\n#   `poblacion-1977` &lt;dbl&gt;, `poblacion-1982` &lt;dbl&gt;, `poblacion-1987` &lt;dbl&gt;,\n#   `poblacion-1992` &lt;dbl&gt;, `poblacion-1997` &lt;dbl&gt;, `poblacion-2002` &lt;dbl&gt;,\n#   `poblacion-2007` &lt;dbl&gt;, `esperanza_de_vida-1952` &lt;dbl&gt;,\n#   `esperanza_de_vida-1957` &lt;dbl&gt;, `esperanza_de_vida-1962` &lt;dbl&gt;,\n#   `esperanza_de_vida-1967` &lt;dbl&gt;, `esperanza_de_vida-1972` &lt;dbl&gt;, …\n\n\nEn esta llamada también está el argumento names_sep, que determina el caracter que se usa para crear el nombre de las nuevas columnas.\n\n\nCreá una nueva tabla, llamada paises_superduper_ancho que tenga una columna para cada variable, anio y país. (Consejo: la tabla final tiene que tener 5 filas).\n¿Cómo es la tabla más ancha posible que podés generar con estos datos? ¿Cuántas filas y columnas tiene?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#uniendo-tablas",
    "href": "06_manipulacion-2.html#uniendo-tablas",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "\n7.3 Uniendo tablas",
    "text": "7.3 Uniendo tablas\nHasta ahora todo lo que usaste de dplyr involucra trabajar y modificar con una sola tabla a la vez, pero es muy común tener dos o más tablas con datos relacionados. En ese caso, tenemos que unir estas tablas. a partir de una o más variables en común o keys. En el mundo de dplyr hay que usar la familia de funciones *_join(). Hay una función cada tipo de unión que queramos hacer.\nAsumiendo que querés unir dos data.frames o tablas x e y que tienen en común una variable A:\n\n\nfull_join(): devuelve todas las filas y todas las columnas de ambas tablas x e y. Cuando no coinciden los elementos en x o y, devuelve NA (dato faltante). Esto significa que no se pierden filas de ninguna de las dos tablas aún cuando no hay coincidencia. Está es la manera más segura de unir tablas, para no perder datos.\nleft_join(): devuelve todas las filas de x y todas las columnas de x e y. Las filas en x que no tengan coincidencia con y tendrán NA en las nuevas columnas. Si hay múltiples coincidencias entre xe y, devuelve todas las coincidencias posibles.\nright_join(): es igual que left_join() pero intercambiando el orden de x e y. En otras palabras, right_join(x, y) es idéntico a left_join(y, x).\ninner_join(): devuelve todas las filas de x donde hay coincidencias con y y todas las columnas de x e y. Si hay múltiples coincidencias entre x e y, entonces devuelve todas las coincidencias. Esto significa que eliminará las filas (observaciones) que no coincidan en ambas tablas, lo que puede ser peligroso.\nanti_join(): devuelve todas las filas de x que no tienen coincidencias con y. Identifica observaciones no coincidentes entre dos conjunto de datos. Es muy util para encontrar datos faltantes o para eliminar datos duplicados.\n\n\nAhora vamos a seguir trabajando con las base de datos de paises pero nos vamos a quedar solo con las observaciones del 2007 y de paso unirlo a una nueva base de datos co2 que contiene información de la emisión de dióxido de carbono de cada país para ese mismo año.\n\npaises_2007 &lt;- datos::paises %&gt;% \n  filter(anio == 2007) \n\nco2_2007 &lt;- readr::read_csv(\"https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/co2_2007.csv\")\nco2_2007\n\n# A tibble: 218 × 3\n   codigo_iso emision_co2 pais                  \n   &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;                 \n 1 ABW            27.9    Aruba                 \n 2 AFG             0.0854 Afghanistán           \n 3 AGO             1.20   Angola                \n 4 ALB             1.32   Albania               \n 5 AND             6.52   Andorra               \n 6 ARB             4.10   Mundo Árabe           \n 7 ARE            22.4    Emiratos Árabes Unidos\n 8 ARG             4.38   Argentina             \n 9 ARM             1.73   Armenia               \n10 ATG             5.14   Antigua y Barbuda     \n# ℹ 208 more rows\n\n\nEsta nueva tabla tiene 3 columnas: codigo_iso tiene el código ISO de 3 letras de (abreviaturas que se usan internacionalmente), emision_co2 tiene las emisiones anuales per cápita de CO2 en toneladas, pais tiene el nombre del país. Esta última columna también está presente en la tabla paises_2007 y es la que va a servir como variable llave para unir las dos tablas.\nPara unir las dos tablas, cualquier función join requiere cierta información:\n\nlas tablas a unir: son los dos primeros argumentos.\nqué variable o variables (se puede usar más de una!) usar para identificar coincidencias: el argumento by.\n\nUnamos paises_2007 y co2_2007 primero con full_join():\n\npaises_co2_2007 &lt;- full_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 241 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Afgan… Asia        2007              43.8  31889923           975. &lt;NA&gt;      \n 2 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 3 Argel… África      2007              72.3  33333216          6223. &lt;NA&gt;      \n 4 Angola África      2007              42.7  12420476          4797. AGO       \n 5 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 6 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 7 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 8 Baréin Asia        2007              75.6    708573         29796. &lt;NA&gt;      \n 9 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n10 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n# ℹ 231 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nSi miramos de cerca la tabla unida veremos un par de cosas:\n\nTodas las columnas de paises_2007 y de co2_2007 están presentes.\nTodas las observaciones están presentes, aún los países que están presentes en co2_2007 pero no en paises_2007 y viceversa. En esos casos ahora tenemos NA. Esto genera una tabla con 241 filas.\n\nEsta es la opción más segura si no sabemos si todas las observaciones de una tabla están presente en a otra.\nSi solo nos interesa conservar las filas de la tabla de la izquierda, en este caso paises_2007 entonces:\n\npaises_co2_2007 &lt;- left_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 142 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Afgan… Asia        2007              43.8  31889923           975. &lt;NA&gt;      \n 2 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 3 Argel… África      2007              72.3  33333216          6223. &lt;NA&gt;      \n 4 Angola África      2007              42.7  12420476          4797. AGO       \n 5 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 6 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 7 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 8 Baréin Asia        2007              75.6    708573         29796. &lt;NA&gt;      \n 9 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n10 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n# ℹ 132 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nAhora esperamos que la tabla resultante tenga la misma cantidad de filas que paises_2007 y efectivamente eso ocurre. Pero al mismo tiempo varios países en esa tabla no encontraron coincidencia en co2_2007 y por esa razón, la columna nueva columna emisiones_co2 tiene NA.\nSi quisiéramos quedarnos solo con las observaciones que están presentes en ambas tablas usamos inner_join().\n\npaises_co2_2007 &lt;- inner_join(paises_2007, co2_2007, by = \"pais\")\npaises_co2_2007\n\n# A tibble: 119 × 8\n   pais   continente  anio esperanza_de_vida poblacion pib_per_capita codigo_iso\n   &lt;chr&gt;  &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt; &lt;chr&gt;     \n 1 Alban… Europa      2007              76.4   3600523          5937. ALB       \n 2 Angola África      2007              42.7  12420476          4797. AGO       \n 3 Argen… Américas    2007              75.3  40301927         12779. ARG       \n 4 Austr… Oceanía     2007              81.2  20434176         34435. AUS       \n 5 Austr… Europa      2007              79.8   8199783         36126. AUT       \n 6 Bangl… Asia        2007              64.1 150448339          1391. BGD       \n 7 Bélgi… Europa      2007              79.4  10392226         33693. BEL       \n 8 Boliv… Américas    2007              65.6   9119152          3822. BOL       \n 9 Bosni… Europa      2007              74.9   4552198          7446. BIH       \n10 Botsw… África      2007              50.7   1639131         12570. BWA       \n# ℹ 109 more rows\n# ℹ 1 more variable: emision_co2 &lt;dbl&gt;\n\n\nEn este caso, perdemos las filas de co2_2007 que no encontraron coincidencia en paises_2007 y viceversa y la tabla resultante tiene aún menos filas (119).\nFinalmente, si quisieramos quedarnos con los paises para los cuales no tenemos datos de co2, o sea las observaciones en paises_2007 que no tienen coincidencia en co2_2007 usamos anti_join().\n\nsin_co2_2007 &lt;- anti_join(paises_2007, co2_2007)\n\nJoining with `by = join_by(pais)`\n\nsin_co2_2007\n\n# A tibble: 23 × 6\n   pais              continente  anio esperanza_de_vida poblacion pib_per_capita\n   &lt;fct&gt;             &lt;fct&gt;      &lt;int&gt;             &lt;dbl&gt;     &lt;int&gt;          &lt;dbl&gt;\n 1 Afganistán        Asia        2007              43.8  31889923           975.\n 2 Argelia           África      2007              72.3  33333216          6223.\n 3 Baréin            Asia        2007              75.6    708573         29796.\n 4 Benin             África      2007              56.7   8078314          1441.\n 5 Camboya           Asia        2007              59.7  14131858          1714.\n 6 República Centro… África      2007              44.7   4369038           706.\n 7 Comoras           África      2007              65.2    710960           986.\n 8 Congo             África      2007              55.3   3800610          3633.\n 9 Yibuti            África      2007              54.8    496374          2082.\n10 Guinea Bissau     África      2007              46.4   1472041           579.\n# ℹ 13 more rows\n\n\n\nEstuvimos trabajando con una parte de la base de datos de emisiones. Pero también está disponible co2_completo.csv que contiene las emisiones para distintos años. El objetivo es que unas paises y co2 teniendo en cuenta tanto el país como el año. Para eso:\n\nLee la base de datos co2_completo.csv en una nueva variable que se llame co2.\nRevisá el nombre de las variables en esta base de datos, ¿se llaman igual que las variables en paises?\nUní las dos tablas usando full_join(), tené en cuenta que ahora usamos dos variables llave pais y anio. Buscá en la documentación cómo indicarle eso a la función full_join().\n\nPodés descargar los datos desde https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/co2_completo.csv",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "06_manipulacion-2.html#ex-manipulacion",
    "href": "06_manipulacion-2.html#ex-manipulacion",
    "title": "\n7  Manipulación de datos ordenados II\n",
    "section": "\n7.4 Construyendo un paquete de R paso a paso",
    "text": "7.4 Construyendo un paquete de R paso a paso\n\nPivots!\nRecordás el ejercicio 3 de dplyr?\n\n¿Cuál es el promedio de la temperatura de abrigo a 150 cm en cada estación? ¿Y el desvío estandar? Pista: la mayoría de las funciones tienen un argumento para sacar los NA del cálculo, revisá la documentación de mean() y de sd().\n\n\nUsando las funciones pivot_ alargá el resultado anterior de tal manera que queden los valores de temperatura máxima y mínima en la misma columna.\nA continuación usando el resultado anterior volvé a ensanchar la tabla de tal manera que tengas columnas con los nombres de las estaciones y en las filas los valores de la media y el desvio estandar.\n\nuniones\nA la hora de analizar datos meteorológicos, tener en cuenta la ubicación y altitud de las estaciones donde se toman las mediciones es muy importane. Sin embargo eso no está incluido en los datos con los que venimos trabajando.\nEsta información son metadatos y suelen venir por separado (si tenemos suerte!). En este caso los tenemos y están disponibles en https://raw.githubusercontent.com/rse-r/intro-programacion/main/datos/metadatos_completos.csv.\n\nLee los metadatos\nIdentifica cuales son las variables clave, aquellas que son comunes entre los datos meteorológicos con los que venís trabajando y esta nueva tabla.\nUní los datos con joins. ¿Cuál es la mejor opción?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Manipulación de datos ordenados II</span>"
    ]
  },
  {
    "objectID": "07_funciones.html",
    "href": "07_funciones.html",
    "title": "\n8  Funciones\n",
    "section": "",
    "text": "8.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#objetivos-de-aprendizaje",
    "href": "07_funciones.html#objetivos-de-aprendizaje",
    "title": "\n8  Funciones\n",
    "section": "",
    "text": "Convertir un bloque de código R en una función\nUtilizar funciones de otros paquetes en una función de su propio paquete\nDevolver un mensaje de error desde una función",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#trabajando-con-funciones-y-otro-código",
    "href": "07_funciones.html#trabajando-con-funciones-y-otro-código",
    "title": "\n8  Funciones\n",
    "section": "\n8.2 Trabajando con funciones y otro código",
    "text": "8.2 Trabajando con funciones y otro código\nHasta ahora tenemos un proyecto con una determinada estructura de carpetas que nos permite ordenar nuestro trabajo. Inicialmente escribir el código necesario para resolver un problema, leer un archivo o calcular medidas estadísticas es lo más razonable. Pero es posible que te encuentres repitiendo las mismas lineas de código o copiado y pegando código de un lado para el otro porque necesitás reutilizar algo que ya escribiste.\nEn estas situaciones es una buena idea comenzar a encapsular código en funciones. En esta sección veremos cómo escribir funciones, más adelante empaquetaremos esas funciones en un paquete.\nEscribir funciones tiene cuatro grandes ventajas sobre copiar y pegar código:\n\nPodés nombrar tus funciones con un nombre descriptivo que facilite la comprensión del código.\nSi por alguna razón tenés que cambiar el código, sólo necesitás hacerlo en un único lugar.\nEliminás la posibilidad de cometer errores al copiar y pegar código.\nPodés reutilizar el código en las funciones en otros proyectos.\n\nEn las situaciones donde nuestro código no produce salidas como gráficos o tablas, más bien son definiciones de funciones secundarias u otras herramientas, no tiene tanto sentido usar archivos .Rmd o .qmd. En estos casos podemos volver a los tradicionales scripts (.R).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#esqueleto-de-una-función",
    "href": "07_funciones.html#esqueleto-de-una-función",
    "title": "\n8  Funciones\n",
    "section": "\n8.3 Esqueleto de una función",
    "text": "8.3 Esqueleto de una función\nCualquier función en R tendrá la siguiente pinta (se le llama firma de una función):\nnombre_de_funcion &lt;- function(arg1, arg2, ...) {\n# código que hace algo \n}\nComo habrás notado necesitamos la función function() para crear una función. Hay tres pasos clave para crear una nueva función:\n\nTenés que elegir un nombre para la función.\nEnumeras los argumentos, que son los elementos de entrada que necesita el código para correr, en el ejemplo arg1, arg2, ....\nColocás el código que has desarrollado en el cuerpo de la función, que se identifica como un bloque entre {} inmediatamente después de function(...).\n\nImaginemos que trabajamos en una carpinteria y vendemos piezas de maderas precortadas para armar muebles. Algunos de los planos de los muebles vienen en pulgadas, pero en Argentina se trabaja en centimetros. Tenemos este código que nos permite transformar las medidas:\n\nlargo_tabla_en_pulgadas &lt;- 12 # En pulgadas!!\n\nlargo_tabla_cm &lt;- largo_tabla_en_pulgadas * 2.54 # convierto a centímetros\n\nEste código no va a ser útil si querés usarlo en otros lugares, por ejemplo si queremos calcular el ancho o queremos convertir la medida de otra pieza que no sea una tabla. Entonces necesitamos generalizarlo en una función.\nEl primer paso es pensar un nombre, por ejemplo pulgadas_a_centimetros. Luego tenemos que analizar el código e identificar cuáles son los argumentos, la información que necesita la función, en este caso el largo en pulgadas, ese es un argumento.\n\npulgadas_a_centimetros &lt;- function(largo_en_pulgadas) {\n  largo_en_pulgadas * 2.54\n}\n\nEsta función está lista para usar, por ejemplo podemos convertir 20 pulgadas a centímetros:\n\npulgadas_a_centimetros(20)\n\n[1] 50.8\n\n\nSi bien podemos nombrar a los argumentos de las funciones de cualquier manera, largo_en_pulgadas no es ideal para una función general. Un mejor nombre podría ser medida_pulgadas.\n\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n  medida_pulgadas * 2.54\n}\n\nEs posible que te encuentres con algo del estilo:\n\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n  medida_centimetros &lt;- medida_pulgadas * 2.54\n  return(medida_centimetros)\n}\n\nUsar la función return() no es necesario, R devuelve el último elemento con o sin el return() presente. Sin embargo, puede ayudar a la lectura del código cuando la función es más compleja.\n\nCada vez que se ejecuta una función se crea un nuevo entorno, desde cero, propio de la función para contener su ejecución. Notá que si buscás la variable medida_centimetros en el Environment no la vas a encontrar. Eso es así porque todo lo que ocurre adentro de la función, se queda adentro de la función. El código corre en ese “entorno” independiente del entorno general.\n\nAquí podemos hacer un paréntesis para mencionar la necesidad de documentar apropiadamente cualquier función o código que generemos. Para una función deberíamos incluir:\n\nQué hace o cuál es su propósito.\nQué argumentos requiere y de qué tipo de datos son.\nQué genera como resultado.\n\n\n\nCreá un archivo .R con las siguientes funciones:\n\n\nUna función que convierta longitudes de centímetros a pulgadas.\nUna función utilizando el siguiente código mean(is.na(x)). ¿Qué resultado da este código? Probalo con x &lt;- c(0, 1, 2, NA, 4, NA).\nUna función utilizando el siguiente código x / sum(x, na.rm = TRUE). ¿Qué resultado da este código? Probalo con x &lt;- c(1:5).\n\n\nGuardá el archivo .R con un nombre informativo.\nAl comienzo del archivo, en comentarios, antes de cada función, incluí qué hace la función, qué argumentos requiere y qué genera.\n\n\nAhora, si quisiéramos usar esa función en el análisis, podemos “cargarla” con source(\"nombre_archivo.R\").\nLa escritura de una función debería arrancar con un código que ya funciona. Es decir, en lugar de empezar desde cero pulgadas_a_centimetros() usamos el código que ya tenemos y que funciona para un ejemplo particular. Luego, cambiando el nombre del argumento, podemos generalizar el código.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#testeá-tu-función",
    "href": "07_funciones.html#testeá-tu-función",
    "title": "\n8  Funciones\n",
    "section": "\n8.4 Testeá tu función",
    "text": "8.4 Testeá tu función\nEs importante que pruebes tu función de distintas maneras. Primero, con algún valor para el que sabés el resultado, por ejemplo 1 pulgada son 2.54 centímetros.\n\npulgadas_a_centimetros(1)\n\n[1] 2.54\n\n\nTambién es importante testear la función con datos diferentes, por ejemplo en vez de 1 número entero, podemos usar un número real o un vector de números.\n\npulgadas_a_centimetros(7.5)\n\n[1] 19.05\n\n\n\npulgadas_a_centimetros(c(0, 1, 12))\n\n[1]  0.00  2.54 30.48\n\n\nHay que chequear si estos resultados son correctos. ¿Esperabas obtener 3 valores en este último ejemplo? ¿tiene sentido que haga esto?\nFinalmente, tenemos que probar la función con otras cosas.\n\npulgadas_a_centimetros(\"100\")\n\nError in medida_pulgadas * 2.54: non-numeric argument to binary operator\n\n\n\npulgadas_a_centimetros(TRUE)\n\n[1] 2.54\n\n\nEl primer ejemplo da un error, poco informativo pero un error al fin. El segundo ejemplo devuelve un resultado, pero ¿no debería dar error?\nPor estas situaciones es importante chequear que lo que ingresa a la función es lo esperado, antes de hacer ninguna otra operación.\n\n8.4.1 Revisá que los argumentos sean válidos\nPara revisar que los argumentos sean válidos, podemos usar if y else. En el caso de que el argumento no sea válido, podemos devolver un mensaje de error que le indique a quien usa la función que fue lo que falló y posiblemente como podria solucionar el error.\n\nPara lo que sigue vamos a necesitar usar esquemas de flujo, if, else, etc. Revisemos cómo es la sintaxis en R.\nif (condición) {\n# código que se ejecuta cuando la condición es TRUE\n} else {\n# código que se ejecuta cuando la condición es FALSE\n}\nEn R la condición que evaluamos va entre () y usamos {} para separar cada rama de nuestro código, no es necesario indentar las líneas de código (aunque ayuda en la lectura!).\nAdemás de if y else, podemos usar else if cuando queremos probar distintas condiciones.\n\nEl paquete cli nos permite escribir mensajes de error y warnings (advertencias en inglés) más claras e informativos. En el caso de que la función reciba un argumento que no es numérico, podemos usar cli::cli_abort() para generar un mensaje de error más claro:\n\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n  \n  if (!is.numeric(medida_pulgadas)) {\n    cli::cli_abort(c(\n      \"medida_pulgadas debe ser numérico.\",\n      \"i\" =  \"La variable ingresada es un {class(medida_pulgadas)[1]}.\"\n    ))\n  }\n  \n  medida_pulgadas * 2.54\n}\n\n\npulgadas_a_centimetros(\"100\")\n\nError in `pulgadas_a_centimetros()`:\n! medida_pulgadas debe ser numérico.\nℹ La variable ingresada es un character.\n\n\nEl mensaje de error se ve mejor y nos permite organizar la información. En este caso usamos cli_abort() pero hay toda una familia de funciones según la circunstancia, por ejemplo si queremos mostrar un warning, si la función corrió con éxito, etc.\nAdemás podemos mostrar distintos tipos de mensajes:\n\ncli::cli_bullets(c(\n  \"noindent\",\n  \" \" = \"indent\",\n  \"*\" = \"bullet\",\n  \"&gt;\" = \"arrow\",\n  \"v\" = \"success\",\n  \"x\" = \"danger\",\n  \"!\" = \"warning\",\n  \"i\" = \"info\"\n))\n\nnoindent\n\n\n  indent\n\n\n• bullet\n\n\n→ arrow\n\n\n✔ success\n\n\n✖ danger\n\n\n! warning\n\n\nℹ info\n\n\n\nEscribí una función para descargar y leer los datos de pingüinos.\n\nLa función debe aceptar un argumento, la ruta al archivo en tu computadora.\nRevisá si el archivo ya existe en esa ruta, usá la función file.exist().\n\n\nSi el archivo no está descargado, el código debe descargarlo y luego leerlo.\nSi el archivo ya está descargado, el código debe leerlo.\n\n\nAgrega mensajes con cli_inform() para que el usuario sepa lo que la función hizo.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#escribí-funciones-para-humanos-y-computadoras",
    "href": "07_funciones.html#escribí-funciones-para-humanos-y-computadoras",
    "title": "\n8  Funciones\n",
    "section": "\n8.5 Escribí funciones para humanos y computadoras",
    "text": "8.5 Escribí funciones para humanos y computadoras\nEs importante recordar que las funciones no son sólo para que las entienda R, sino también para las personas que las van a usar. A R no le importa cómo se llama tu función, o qué comentarios contiene, pero éstos son importantes para que vos y otras personas entiendan lo que hace.\nEl nombre de una función es importante. Lo ideal es que el nombre de tu función sea corto, pero que describa claramente lo que hace la función. Eso es difícil. Pero es mejor que el nombre sea claro a que sea muy corto. También que ayude a RStudio a autocompletar.\nGeneralmente, los nombres de las funciones son verbos, y los argumentos sustantivos.Esto es porque las funciones hacen algo, tienen una acción asociada. Por supuesto, hay excepciones a la regla. Los sustantivos como nombre de funciones están bien si la función calcula un sustantivo muy conocido (por ejemplo, promedio() es mejor que calcula_promedio()), o accede a alguna propiedad de un objeto (por ejemplo, coef() es mejor que extraer_coeficientes()). Una buena señal de que un sustantivo puede ser una mejor opción es si se utiliza un verbo muy amplio como «obtener», «computar», «calcular» o «determinar». Usa tu mejor criterio y no tengas miedo de cambiar el nombre de una función si más adelante se te ocurre uno mejor.\nMuy corto\n\nf()\n\nNo es un verbo y no es descriptivo\n\nfuncion_hermosa()\n\nNombre largo pero claro\n\ncomputa_faltantes()\ncolapsa_anios()\n\nSi el nombre de tu función está compuesto por varias palabras, te recomendamos utlizar «snake_case», donde cada palabra en minúscula está separada por un guión bajo. camelCase es otra buena alternativa (es mas amigable con lectores de pantallas). Lo importante es ser coherente: elegí una y no cambies.\nPara ayudar a RStudio a autocompletar el nombre de las funciones es mejor esto:\n\ninput_select()\ninput_checkbox()\ninput_text()\n\nque esto:\n\nselect_input()\ncheckbox_input()\ntext_input()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "07_funciones.html#ex-funciones",
    "href": "07_funciones.html#ex-funciones",
    "title": "\n8  Funciones\n",
    "section": "\n8.6 Construyendo un paquete de R paso a paso",
    "text": "8.6 Construyendo un paquete de R paso a paso\n\n\nCrea una función para descagar y leer los datos de estaciones. Importante:\n\n\nUsá como base la función que creamos para leer los datos de pinguinos.\nLa función deberá recibir 2 argumentos, el id de la estación (por ejemplo “NH0437”) y la ruta donde se guardará el archivo (por ejemplo “datos/NH0437.csv”)\nDebe poder descargar y leer los datos de cualquier estación.\n\n\nCrea una función que se llame tabla_resumen_temperatura y que devuelva una tabla de resumen de la temperatura_abrigo_150cm para una o más estaciones. Usá el código que generaste en el ejercicio 1 de tidyr.\nGenerá una función grafico_temperatura_mensual que devuelva un gráfico que muestre el promedio mensual de la temperatura de abrigo. usá el código que generaste para el ejercicio 2 de ggplot2. La función debe:\n\n\nRecibir el data.frame con los datos (que pueden ser de 1 o más estaciones).\nTener un argumento para indicarle que colores debe usar para el gráfico.\nTener un argumento para definir el título del gráfico. Por defecto, si no se define el título deberá aparecer “Temperatura”\n\nDesafio extra (opcional): modificá la función para que si no le pasas los colores necesarios, elija colores de manera aleatoria. Pista: revisá colors()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "08_git-2.html",
    "href": "08_git-2.html",
    "title": "9  Git para trabajar en equipo",
    "section": "",
    "text": "9.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git para trabajar en equipo</span>"
    ]
  },
  {
    "objectID": "08_git-2.html#objetivos-de-aprendizaje",
    "href": "08_git-2.html#objetivos-de-aprendizaje",
    "title": "9  Git para trabajar en equipo",
    "section": "",
    "text": "Aplicar conceptos de flujos de trabajo usando Git básicos al trabajo colaborativo utilizando GitHub.\nComprender como los conflictos de versiones se generan y como resolverlos.\nIdentificar las diferencias entre branchs y forks e identificar situaciones en las que utilizar cada una.\nComprender el uso y el rol de las branchs y los pull requests en la colaboración en un proyecto.\nGestiona pull requests como responsable o líder de un proyecto.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git para trabajar en equipo</span>"
    ]
  },
  {
    "objectID": "08_git-2.html#flujo-de-trabajo-individual",
    "href": "08_git-2.html#flujo-de-trabajo-individual",
    "title": "9  Git para trabajar en equipo",
    "section": "9.2 Flujo de trabajo individual",
    "text": "9.2 Flujo de trabajo individual\nEn este capítulo vamos a ver que pinta tiene el flujo de trabajo colaborativo entre personas para hacer análisis de datos y desarrollo de software. Previamente estuviste trabajando con git de manera individual:\nModificar un archivo --&gt; Add --&gt; Commit --&gt; Push\nAsí que cada vez hagas un push, git comparará los archivos en el repositorio remoto con la versión que actualizaste localmente y actualizará el repo remoto para que todo este sincronizado. Pero cuando se trabaja con otras personas hay casos que potencialmente pueden crear conflictos de merge o versiones. Aunque el nombre sugiera lo contrario, un conflicto de merge no es necesariamente un error, ocurre cuando la versión de un archivo en el repositorio local no es compatible con su versión en el repositorio remoto. A veces, Git es capaz de combinar los dos conjuntos de cambios sin ningún problema. Pero a veces esto no es posible, y requiere que un humano intervenga y decida cómo deben combinarse los múltiples cambios, ¿mantiene la versión A, la versión B o una combinación de ambas?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git para trabajar en equipo</span>"
    ]
  },
  {
    "objectID": "08_git-2.html#identificando-conflictos-de-versiones",
    "href": "08_git-2.html#identificando-conflictos-de-versiones",
    "title": "9  Git para trabajar en equipo",
    "section": "9.3 Identificando conflictos de versiones",
    "text": "9.3 Identificando conflictos de versiones\nImaginá que alguien en tu equipo cambia el contenido de archivo R/pulgadas_a_centimetros.R para cambiar el mensaje de \"medida_pulgadas debe ser numérico.\" a \"medida_pulgadas debe ser **de tipo** numérico.\":\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n  \n  if (!is.numeric(medida_pulgadas)) {\n    cli::cli_abort(c(\n      \"medida_pulgadas debe ser de tipo numérico.\",\n      \"i\" =  \"La variable ingresada es un {class(medida_pulgadas)[1]}.\"\n    ))\n  }\n  \n  medida_pulgadas * 2.54\n}\nAl mismo tiempo, vos también cambiaste esta línea en el código pero decidiste que el mensaje de error debe ser \"medida_pulgadas debe ser **una variable numérica**.\". Cuando intentás hacer push de la nueva versión del archivo al repositorio remoto te encontrás con este mensaje:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/master\nTo github.com:paocorrales/paqueteprueba.git\n ! [rejected]        HEAD -&gt; master (fetch first)\nerror: failed to push some refs to 'github.com:paocorrales/paqueteprueba.git'\nhint: Updates were rejected because the remote contains work that you do not\nhint: have locally. This is usually caused by another repository pushing to\nhint: the same ref. If you want to integrate the remote changes, use\nhint: 'git pull' before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nEl mensaje nos aconseja hacer pull antes de intentar hacer push para actualizar el repositorio remoto. Al hacer pull nos encontramos con el siguiente problema:\n&gt;&gt;&gt; /usr/bin/git pull\nFrom github.com:paocorrales/paqueteprueba\n   6e63458..d7d2a6c  master     -&gt; origin/master\nAuto-merging R/pulgadas_a_centimetros.R\nCONFLICT (content): Merge conflict in R/pulgadas_a_centimetros.R\nAutomatic merge failed; fix conflicts and then commit the result.\nEl mensaje dice que hay conflictos con el contenido de R/pulgadas_a_centimetros.R y que el merge automático falló. La buena noticia es que ya sabemos cuál es el archivo que da problemas. Aquí, hacer commits con pequeños cambios ayuda mucho.\nAhora, si revisamos el archivo R/pulgadas_a_centimetros.R, el contenido cambió:\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n\n  if (!is.numeric(medida_pulgadas)) {\n    cli::cli_abort(c(\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n      \"medida_pulgadas debe ser una variable numérica.\",\n=======\n      \"medida_pulgadas debe ser de tipo numérico.\",\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; d7d2a6cf0e03652e1ff52e7cf5eb2da96fe69312\n      \"i\" =  \"La variable ingresada es un {class(medida_pulgadas)[1]}.\"\n    ))\n  }\n\n  medida_pulgadas * 2.54\n}\nEstos simbolos &lt;&lt;&lt;&lt;&lt;&lt;&lt;, ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; fueron agregados por git para resaltar el contenido que está generando conflictos. Todo lo que hay entre &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD y ======= corresponde a la versión local, y el contenido entre ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; es la versión actualmente en GitHub. La cadena larga es el identificador del commit en Github y HEAD refiere al último commit local.\nPara arreglar el conflicto será necesario:\n\nEliminar las lineas que agrego git.\nElegir una de las 2 versiones en conflicto o generar una nueva versión que incluya todos los cambios.\nGuardar el archivo y hacer un nuevo commit, que normalmente tiene como mensaje “arregla conflicto de merge”.\n\nAlgunas herramientas como GitHub Desktop y GitKraken tienen una interfaz gráfica que permite resolver estos conflictos de manera rápida, sin embargo el mecanismo en el fondo es el mismo.\nLos conflictos de merge pueden suceder si cambiaste algo en GitHub, olvidaste hacer pull localmente y cambiaste el mismo archivo localmente. Aunque los conflictos son parte de trabajar con control de versiones, vamos a tratar de evitarlos en la medida de lo posible.\n\n9.3.1 1. Primero, hace pull\nEs recomendable hacer pull antes de empezar a trabajar con los archivos de un repositorio, ya que así empezarás a trabajar con la versión más actualizada del repositorio.\n\n\n9.3.2 2. Cada persona trabaja en archivos diferentes\nLa forma más fácil de evitar conflictos de merge es pedir a cada persona que trabaje en archivos diferentes y que no editen los archivos de otras personas. Esto funciona pero tiene limitaciones.\nA largo plazo, es posible que tengas que trabajar en el código de otra persona y, en esos casos, la comunicación entre los miembros del equipo es fundamental.\n\n\n9.3.3 3. Las personas se turnan\nEs posible que más de una persona esté trabajando en el mismo archivo, ya sea un script o documentación. Por lo general, ese será un trabajo para muchas personas. Una solución es turnarse: vos trabajás en el archivo por la mañana y tu compañero/a lo hace por la tarde.\n\n\n9.3.4 4. Las personas trabajan en branchs\nAquí es donde aprovechamos al máximo lo que git tiene para ofrecer.\nLas branchs (ramas en inglés) parecen un concepto nuevo, pero en realidad, siempre estás trabajando en una rama sin darte cuenta. La branch “predeterminada” en general se llama main porque es la principal, y todo este tiempo estuviste “agregando commits a la branch main”.\nUna branch en git es una etiqueta que apunta a un commit específico en el repositorio a partir de la cual se crean otras versiones paralelas. Trabajar en una branch te permite modificar archivos sin modificar los mismos archivos en otras branchs, porque esencialmente estás trabajando en un conjunto de archivos independientes. Cuando quieras pasar los cambios de tu branch a la branch main, tendrás que hacer un merge para combinar las ramas.\n\n\n\n“Diagrama de un árbol git que muestra la branch principal con 4 commits y una branch secundaria llamada función que comienza desde el commit 2 en la branch main y tiene 2 nuevos commits, independientes de la principal.”\n\n\nHay diferentes formas de utilizar branchs Quizás cada persona del equipo tiene una branch y trabaja en ella hasta que llega el momento de hacer un merge a la branch main. O quizás, y esto es más común, cada branch represente un nuevo desarrollo que se agrega al paquete. Por ejemplo, si agregás una nueva función, creás una branch, desarrollas el código y luego hacer un merge para incorporar la función al paquete.\nTrabajar con branchs no eliminará los conflictos del todo. Es posible que estos aparezcan cuando intentes hacer merge entre tu branch con la branch principal. Pero esto pasará una sola vez y solo cuando lo decidas.\nAntes de revisar cómo es el flujo de trabajo con branchs, hay un nuevo concepto que debemos mencionar: un pull request o PR es una herramienta de GitHub que te permite realizar cambios en una branch y luego solicitar a quien mantiene el repositorio que fusione esos cambios en la branch principal. Los pull request pueden surgir de forks (que presentaremos más adelante) o de branchs independientes dentro del repositorio. Permiten a quienes mantienen y colaboran en un proyecto, revisar, discutir, solicitar y aprobar los cambios y sumarlos al repositorio cuando estan listos.\n\n9.3.4.1 Escenario 1\nEste diagrama muestra el flujo de trabajo cuando se desea contribuir al repositorio utilizando branchs y además, asumimos que tenés permisos de escritura en el repositorio remoto:\n\n\nCloná el repositorio en tu computadora\nCrear una nueva branch.\nEdita archivos, agregalos y hacé commits en esa branch.\nCuando los cambios estén hechos y listos, envía un pull request al repositorio remoto para comparar tus cambios en tu branch con main.\nEl pull request es aceptado y fusionado o hay que hacer nuevos cambios (vuelve al paso 3).\nUna vez que el PR es aceptado y fusionado, la branch principal tiene ahora los cambios actualizados y ya se puede eliminar la branch donde estabas trabajando.\nEl proceso puede repetirse varias veces, en paralelo o en secuencia dependiendo del tamaño del equipo.\n\n\n\n9.3.4.2 Escenario 2\nSi no tenés permisos de escritura en el repositorio remoto, tendrás que utilizar forks. Esto es muy habitual cuando querés colaborar en un proyecto del que no formas parte.\nUn fork es una copia del repositorio de otra persona o equipo que se almacenará en tu cuenta de GitHub. Tanto el repositorio original como el fork se encuentran en GitHub, la diferencia es que puedes modificar y actualizar la versión que se encuentra en tu cuenta.\n\n\nCrear un fork del repositorio principal (si aún no lo tenés).\nCloná el repositorio en tu computadora.\nCrear una nueva branch en tu copia del repositorio.\nRealiza ediciones y cambios en los archivos y envíalos a la branch.\nCuando esté todo listo, abrí el pull request. Si te piden nuevos cambios tendrás que volver al paso 4.\nSi el PR aceptado y fusionado, la branch principal en el repositorio principal se actualizará y la nueva branch se puede borrar.\nFinalmente podés sincronizar tu fork del repositorio con el repositorio principal.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git para trabajar en equipo</span>"
    ]
  },
  {
    "objectID": "08_git-2.html#cómo-trabajar",
    "href": "08_git-2.html#cómo-trabajar",
    "title": "9  Git para trabajar en equipo",
    "section": "9.4 Cómo trabajar",
    "text": "9.4 Cómo trabajar\nUn reto que surge a menudo es saber cómo y cuándo usar branchs. ¿Hacés todos cambios cambios allí y luego abris un PR a la branch main? ¿creás una branch, haces PR y y la borras inmediatamente después? ¿Qué cambios haces en la nueva branch? La respuesta a estas preguntas dependen del contexto, del equipo, del paquete en el que estés trabajando, de cuáles sean tus objetivos para el paquete, etc. Sin embargo, te damos algunos consejos:\n\nCuando haces cambios pequeños y enfocados con un error u objetivo específico (por ejemplo, actualizar la documentación para arreglar un error de tipeo) creá un nueva branch y abrí un PR. Cuanto más pequeños sean los cambios más fácil será revisarlos y aceptarlos.\nSi hacés grandes cambios, lo mejor es que estén relacionados a un problema u objetivo, de modo que al revisar el PR sea más fácil seguirlo y entenderlo. Dividí tus contribuciones por problema u objetivo.\nHaz cambios relacionados con un issue específico y agregá comentarios en el issue para mantener a todo el mundo al tanto.\n\nVamos a mostrar algunos ejemplos de cómo utilizar los flujos de trabajo que vimos recién en distintas situaciones.\n\nDesarrollando software de manera individual En este caso, probablemente tengas que pensar si tenés que hacer una branch, ya que podés trabajar fácilmente con git sin hacer nunca una branch. Sin embargo, si quisieras experimentar con el código (o texto) sin modificar la branch main, estarás en el escenario 1.\nDesarrollando software de manera individual pero otras personas colaboran Si estás trabajando en un paquete R de código abierto y hay personas que ocacionalmente contribuyen a tu paquete, como resposanble de mantenerlo y desarrollarlo recibirás issues y PR que tendrás que revisar y responder. En este caso es muy importante utilizar branches para reducir la posibilidad de que hagas un cambio en main que puedan afectar a usuarios de tu paquete.\nColaborando en un proyecto del que no sos parte Si contribuís ocasionalmente con un paquete de R, tendrás que usar el flujo de trabajo del escenario 2. Tendrás que hacer un fork del repositorio del paquete, hacer cambios en nuevas branchs, y abrir PR para proponer esos cambios en el paquete. Este escenario es el más habitual en el mundo de los paquetes R de código abierto, ya que la mayoría de los paquetes son mantenidos por una o varias personas.\nComo miembro de un equipo Si tenés permisos de escritura en el repositorio y formás parte de un equipo que trabaja en ese repositorio, podés trabajar siguiendo el flujo de trabajo en el escenario 1. Harás cambios en los archivos creando primero una branch y, cuando el cambio esté listo, enviarás los cambios al repositorio remoto abriendo un PR para que otras personas en el equipo puedan revisar tu propuesta.\n\n\n¿Qué flujo de trabajo necesitan estas situaciones?\nConsiderá estas situaciones y decidí que flujo de trabajo que utilizarías para cada una de ellas.\n\nEstás en una clase en la que una de las tareas es un trabajo en grupo para crear un paquete de software. ¿Cuál de los flujos de trabajo anteriores será el mejor enfoque para completar un proyecto en equipo? ¿Se te ocurren otros enfoques que puedan funcionar igual de bien? ¿Qué ¿Cuáles son los puntos fuertes y débiles de cada enfoque?\nUn amigo/a se entera de que estás creando un paquete R en tu tiempo libre y quiere contribuir. ¿Qué instrucciones le darías a tu amigo/a para que pueda contribuir? ¿Qué enfoque funcionaría mejor para vos?\nMientras navegás por la página web de un paquete de R, encontrás algunos errores de tipeo y decidís arreglarlos. ¿Cuál de los enfoques anteriores utilizarías?\n\n\n\n9.4.1 Plantemos árboles!\nComo ejemplo y ejercicio colaboraremos con la recientemente abierta galeria de arte Flametree, y haremos PRs en el camino.\n\nFork del repositorio\n\nIngresá a github.com/paocorrales/flametree_gallery\nHacé un fork del repositorio utilizando el botón “Fork” de la esquina superior derecha.\n\n\n\n\nCaptura de pantalla de un repositorio mostrando dónde está el botón “Fork”.\n\n\nAhora tenés una copia del repositorio en tu cuenta de GitHub.\n\nCopia la url del repositorio y clónalo en tu computadora siguiendo las instrucciones para crear un nuevo repositorio que vimos en la sección de git trabajando de manera individual.\n\n\n\n\nCaptura de pantalla de un repositorio forkeado mostrando dónde copiar la url para clonar el repositorio.\n\n\n\nAhora tenés un proyecto RStudio (que también es un repositorio) que es una copia del que está en el repositorio original. Es un proyecto muy pequeño con unos pocos archivos. template_script.R incluye el código necesario para crear bellas imágenes como ésta:\n\n\n\nImagen de árboles creada con R\n\n\nUtiliza el paquete de R flametree creado por Danielle Navarro. No vamos a discutir en profundidad cómo funciona este paquete, pero es una buena excusa para practicar pull requests.\n\nHacé un cambio en el repositorio\n\nHacé una copia del archivo template_script.R y cámbiale el nombre a &lt;tu-nombre.R&gt;\nCambiá el valor de las 3 primeras variables del script:\n\n\nname: tu nombre.\nseed: porque hay cosas aleatorias en el código.\nshades: elegí 4 colores que te gusten.\n\nPodés ejecutar el código si querés ver tu árbol (necesitarás instalar el paquete).\n\nGuardá el archivo, add al área de preparación y hacé un commit (incluí sólo el archivo .R que creaste).\nHacé push a tu repositorio remoto.\n\n\nHasta este punto hiciste el cambio en tu repositorio local (que es una copia del repositorio principal) y subiste esos cambios a tu repositorio remoto en GitHub. El repositorio original no se enteró de estos cambios porque hasta este punto todo el trabajo lo hiciste en tu repositorio.\nSi querés contribuir con los cambios que hiciste (el archivo .R con el código para crear tu árbol) en el repositorio original, es hora de hacer un pull request.\n\nHacé un pull request\n\nEntrá a tu repositorio en GitHub, ahí encontrarás tu último commit y un mensaje como este:\n\n\n\n\nCaptura de pantalla de un repositorio bifurcado en GitHub con un nuevo commit. Muestra cómo iniciar un nuevo pull request.\n\n\n\nHacé click en “Open pull request”.\nY hacé click en “Create pull request”.\nAhora completá el pull request con un título y un mensaje y luego termina el PR.\n\n\n\n\nCaptura de pantalla de GitHub que muestra cómo añadir un título, un mensaje y finalizar un pull request\n\n\n¡Listo!\n\nQuien esté a cargo del repositorio recibirá un correo electrónico. Pueden revisar el pull request, hacer comentarios y, finalmente, aceptar la contribución. Cuando esto ocurra, los cambios que hayas hecho aparecerán en el repositorio.\n\n¿En que escenario trabajamos recién? ¿Cuáles serían la diferencias con el otro escenario?\n\n\nPracticá contribuir a un proyecto en GitHub\nAhora que sabes como contribuir con un proyecto, podés ayudarnos! Estos materiales están plagados de errores de tipeo y cosas para mejorar, y a esta altura seguro encontraste un montón.\nPara practicar como hacer un PR en un repositorio donde no tenés permisos, te proponemos que busques un error y propongas como arreglarlo. Cada una de estas secciones es un archivo .qmd como los que venimos usando y el repositorio se encuentra en github.com/rse-r/intro-programacion.\n\n\nGenerá tu perfil en Github\nVamos a crear el perfil en GitHub. Esto va a permitir que las personas te identifiquen mejor en esa plataforma y que vayas teniendo tu portfolio como cientifico/a de datos y desarrollador de software:\nPara eso tenes que:\n\nCrear un repositorio en tu cuenta con el mismo nombre que tu usuario de github. Por ejemplo, el usuario de GitHub de Yanina es yabellini entonces el repositorio se tiene que llamar yabellini.\nAgregarle un archivo README.md\nPensar en que queres poner en tu perfil y modificar el readme son esa informacion. Hay listado de ejemplos de diferentes perfiles de GitHub para todos los gustos.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git para trabajar en equipo</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html",
    "href": "09_paquetes-1.html",
    "title": "\n10  Empaquetando funciones\n",
    "section": "",
    "text": "10.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#objetivos-de-aprendizaje",
    "href": "09_paquetes-1.html#objetivos-de-aprendizaje",
    "title": "\n10  Empaquetando funciones\n",
    "section": "",
    "text": "Identificar cuándo y por qué crear un paquete R.\nConocer y utilizar los paquetes R devtools y usethis para automatizar y agilizar muchas de las tareas de desarrollo de paquetes.\nAprende a crear un nuevo paquete R utilizando usethis::create_package().\nDescribir y explicar la finalidad de las carpetas y archivos de un paquete de R.\nAprender cómo y por qué puedes añadir datos a un paquete de R.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#por-qué-crear-un-paquete-r",
    "href": "09_paquetes-1.html#por-qué-crear-un-paquete-r",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.2 ¿Por qué crear un paquete R?",
    "text": "10.2 ¿Por qué crear un paquete R?\nEl objetivo principal del desarrollo de software es simplificar alguna tarea o un conjunto de tareas para vos y para los demás (como tu equipo, u otras personas que usen tu trabajo). Esto también se aplica al desarrollo de software en R. Crear un paquete R es una de las formas más potentes de simplificar tareas, independientemente de lo sencillas o complejas que sean.\nA lo largo de esta sección mostraremos que crear y desarrollar un programa R no es tan difícil como parece a primera vista. Pero antes de hacer un paquete, tenes que definir algunas cosas. Por ejemplo, ¿cómo determinar si tiene sentido hacer un paquete R? Respondé a las siguientes preguntas:\n\n¿Creaste alguna vez una función, por sencilla que sea?\n¿Utilizaste esa función más de una vez en más de un proyecto o archivo, ya sea copiándola y pegándola o utilizando el archivo que que la contiene?\n\nSi respondiste afirmativamente a estas dos preguntas, entonces deberías crear un paquete R para esa función. Pero puede que te preguntes, ¿por qué hacer un paquete con una sola función? Porque nunca se acaba con sólo una función, es muy probable sumes otras a tu trabajo. Aparte de empaquetar las funciones de R, si tienes conjuntos de datos pequeños o medianos que utilizas en varios proyectos o archivos, puedes incluso empaquetar los datos.\nAdemás, hacer un paquete de R ahora es mucho más fácil que en el pasado. Esto se debe en gran parte a otros paquetes de R como devtools y usethis que están diseñados para simplificar el desarrollo de paquetes. A esto se suman recursos gratuitos como libros y blogs y páginas en Internet para aprender a crear paquetes R y hacer desarrollo de software en R.\nCrear un paquete R y publicarlo en GitHub o en CRAN como parate de trabajo científico, un proyecto o análisis ayuda a su reproducibilidad. Esto se debe a que hacer un paquete de R suele requerir un mayor nivel de rigor, tests, documentación y inspección del código, lo que significa que tú y los demás podrán confiar más en en los resultados. Y si está en GitHub, es mucho más fácil compartir tu trabajo. con otras pesonas y lo lograr que tu trabajo tenga mayor impacto en general.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#qué-es-un-paquete-r",
    "href": "09_paquetes-1.html#qué-es-un-paquete-r",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.3 ¿Qué es un paquete R?",
    "text": "10.3 ¿Qué es un paquete R?\nPara entender qué es un paquete R, daremos un paso atrás y consideraremos lo que ocurre cuando interactuamos con R. El primer acercamiento a R es a través de la consola, donde escribís funciones en R para realizar tareas que que se imprimen en pantalla. Si no cambiaste la configuración inicial esa sesión de R correrar en tu carpeta raiz, normalmente algo parecido a /home/username/ en Linux, /Users/username/ para macOS, o C:\\Users\\username para Windows. Así que cualquier dato o gráfico que guardes o importes debe incluir la ruta del archivo a la ubicación correcta. Desde un punto de vista reproducible y modular esto va en contra de las buenas prácticas. Asimismo, el código de R qeu escribas en la consola no se guarda en ningún lado. Por tanto, no podés reutilizarlo o compartirlo fácilmente.\nEl siguiente nivel es guardar el código en un scriptde R (un archivo almacenado en cualquier lugar en el ordenador que termina en .R) y hacer que R ejecute este código en secuencia. En el pasado, la gente podía escribir scripts de R en editores de texto como vim, emacs o Notepad, y ejecutar manualmente el script en la consola de R. En la actualidad, la mayoría de la gente utiliza un Entorno de Desarrollo Integrado (IDE) como RStudio o VS Code. Este es el método más utilizado para realizar cualquier tipo de trabajo en R. Teóricamente, el código escrito de esta forma es reproducible y se puede compartir. Sin embargo, en la práctica, las personas escriben código de manera secuencial, resolviendo un problema luego del otro y trabajan con R de forma más interactiva que programáticamente. El directorio de trabajo de un script R en este caso no está definido, por lo que seguimos encontrando problemas similares a los que tenemos al usar la consola. Si bien se puede almacenar código o funciones de R en un script y cargarlas con source() desde otros scripts, esto implica hacer un seguimiento de los archivos con estas funciones y actualizarlos cuando corresponda.\nUn paquete de R no es muy diferente de utilizar varios scripts. Existen ciertas expectativas y convenciones que deben seguirse para para que que el paquete se “instale” en tu computadora y quede disponible como paquete. Algunas de estas convenciones son:\n\nDebe haber un archivo llamado DESCRIPTION que contiene los metadatos necesarios para que R sepa cómo instalar el paquete. Veremos qué debe incluir más adelante.\nDebe haber una carpeta llamada R/. Normalmente sólo contendrá archivos .R y sólo incluirán las funciones que hayas creado. Veremos como incorporar las funciones que ya tenemos dentro de un paquete.\nDebe haber un archivo NAMESPACE que contenga la lista de funciones de tu paquete que esten disponibles para ser usadas. Este archivo se gestiona automáticamente con funciones de devtools y roxygen2.\nLa carpeta que contiene todo, aunque no es obligatorio debería llamarse como el paquete. Por ejemplo, el paquete usethis tiene el nombre de carpeta usethis/. Esto no es un requisito explícito, pero es muy recomendable. R determina el nombre del paquete a partir del campo Package: en el archivo DESCRIPTION.\n\nNada de esto es algo de lo que tengas que preocuparte realmente porque los paquetes usethis y devtools están diseñados para hacer muchas de estas tareas de configuración de paquetes por ti, o al menos simplificarlas.\nHasta ahora interactuaste con paquetes de R instalados en tu computadora con install.packages() y que luego cargas en memoria con library() para poder usar sus funciones. Instalado y en memoria son dos estados posibles de un paquete. Pero ahora, en el contexto del desarrollo de paquetes, empezarás a trabajar con el código fuente. En este estado, el paquete tiene una pinta distinta y el flujo de trabajo también va a cambiar.\nLos 5 estados en los que puede estar un paquete de R son:\n\n\ncódigo fuente o source en inglés: incluye la carpeta y todos los archivos que mencionamos antes.\n\nbundled: es una versión comprimida del paquete, independiente del sistema operativo de las computadoras, a partir del cual puede ser instalado.\n\nbinary o binario: es una versión del paquete lista para instalar, sin embargo depende del sistema operativo. Un binario creado para Windows no funcionará en Linux.\n\ninstalado: es la version del paquete ya instalado en una computadora.\n\nen memoria: el paquete está cargado en el ambiente de R y podemos usar las funciones porque corrimos library(nombre_paquete).\n\n¿Cómo funciona la instalación de paquetes? Depende. Si instalas el paquete desde CRAN, Bioconductor o R-Universe install.packages() va a descargar el bundle o el binario en tu computadora, y lo va a descomprimir la “librería de paquetes de R” (una carpeta medio escondida en tu computadora) y generar los archivos necesario para que puedas usarlo.\nSi instalas tu paquete mientras lo estás desarrollando, R va a tomar el código fuente para generar los archivos necesarios y guardar los en la libreria de paquetes de R, de la misma manera que lo hace con cualquier otro paquete.\nEsta “instalación del paquete” en la libreria no es más que una carpeta con archivos y otras carpetas que contienen el código de las funciones en un formato específico que entiende R. Para ver dónde están instalados los paquetes, utiliza:\n\n.libPaths()\n\n[1] \"/home/paola/R/x86_64-pc-linux-gnu-library/4.5\"\n[2] \"/opt/R/4.5.0/lib/R/library\"                   \n\n\nSi corres esa función en la consola, es posible que el resultado sea un poco diferente a esto, depende de cada computadora. Si .libPaths() muestra más de una ruta, normalmente la primera contendrá todos los paquetes.\n\nlibrary(fs)\n\nprimary_library_path &lt;- .libPaths()[1] #Elegimos la primera ruta\npackages &lt;- dir_ls(path(primary_library_path))\n\n# Número de paquetes instalados\nlength(packages)\n\n[1] 205\n\n# Muestra los primeros 6\nhead(packages)\n\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/DBI\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/DT\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/FNN\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/Formula\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/Lahman\n/home/paola/R/x86_64-pc-linux-gnu-library/4.5/Lmoments",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#nombrar-un-paquete",
    "href": "09_paquetes-1.html#nombrar-un-paquete",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.4 Nombrar un paquete",
    "text": "10.4 Nombrar un paquete\nCrear un paquete no es complicado. Lo complicado es es nombrar el paquete. Crear un nombre significativo, que la gente recuerde y que se pueda buscar en Google es realmente difícil. No hay una manera fácil de y a menudo requiere varios días de pensar opciones. Pero además hay que asegurarse de que el nombre que estamos pensando usar no lo esté usando alguien más. Esto se puede hacer con el paquete pak. Por ahora para revisar el paso a paso para crear un paquete usaremos paqueteprueba como nombre. Revisemos si está disponible\n\n\n╔══════════════════════════════════════════════════════════════════════════════╗\n║                             –*– paqueteprueba –*–                            ║\n╚══════════════════════════════════════════════════════════════════════════════╝\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ ✔  valid name      ✔  CRAN            ✔  Bioconductor    ✔  not a profanity  │\n└──────────────────────────────────────────────────────────────────────────────┘\n┌ Wikipedia ───────────────────────────────────────────────────────────────────┐\n│ Paqueteprueba No definition found                                            │\n└──────────────────────────────────────────────────────────────────────────────┘\n┌ Wiktionary ──────────────────────────────────────────────────────────────────┐\n│ paqueteprueba No English definition found                                    │\n└──────────────────────────────────────────────────────────────────────────────┘\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ Sentiment: :| (0)                                                            │\n└──────────────────────────────────────────────────────────────────────────────┘\n\n\nEn este caso paqueteprueba está disponible para que lo usemos.\n\nTe habrás dado cuenta de que hemos utilizado la sintaxis nombrepaquete::nombrefuncion() unas cuantas veces. Esto le dice a R que utilice la función de un paquete concreto. Así que pak::pak() es decirle a R que utilice la función pak() del paquete pak. En desarrollo de paquetes en particular, utilizaremos esto en lugar de cargar las librerias con library(pak) porque queremos ser explícitos sobre qué función queremos utilizar y porque no necesitamos cargar todas las funciones del paquete cuando sólo queremos utilizar una o dos.\n\n\n10.4.1 Requisitos formales\nExisten tres requisitos formales:\n\nEl nombre sólo puede estar formado por letras, números y puntos, es decir, .\nDebe empezar por una letra.\nNo puede terminar con un punto.\n\nLamentablemente, esto significa que no puede utilizar guiones ni guiones bajos, es decir, - o _, en el nombre del paquete. Desaconsejamos el uso de puntos en los nombres de paquetes, para evitar que se confunda con extensiones de archivos y métodos S3.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#estructura-de-un-paquete",
    "href": "09_paquetes-1.html#estructura-de-un-paquete",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.5 Estructura de un paquete",
    "text": "10.5 Estructura de un paquete\nAhora que tenemos un nombre, el siguiente paso es configurar la infraestructura básica para el paquete. Afortunadamente, el paquete usethis ayuda resolver gran parte del trabajo. Cuando usemosla función usethis::create_package() configurará los archivos y carpetas básicos que necesitamos para crear un paquete y que R lo instale como tal. Utilizaremos esta función para crear el paquete paqueteprueba.\n\nusethis::create_package(path = \"~/Documentos/Courses/paqueteprueba\")\n\nEn este caso estamos creando el paquete en la carpeta Documentos, pero también podríamos crearlo en cualquier otra carpeta. Esta linea de código además se corre en la consola, no tendría sentido que corra en un script ya que no es algo que haremos todos los días. El resultado es el siguiente\n✔ Creating 'C:/Users/tonin/Documentos/paqueteprueba/'\n✔ Setting active project to 'C:/Users/tonin/Documentos/paqueteprueba'\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nPackage: paqueteprueba\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last &lt;first.last@example.com&gt; [aut, cre] (YOUR-ORCID-ID)\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.1\n✔ Writing 'NAMESPACE'\n✔ Writing 'paqueteprueba.Rproj'\n✔ Adding '^paqueteprueba\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✔ Opening 'C:/Users/tonin/Documentos/paqueteprueba/' in new RStudio session\n✔ Setting active project to '&lt;no active project&gt;\nDonde sea que hayas creado el paquete ahora tendrás una carpeta llamada paqueteprueba con los archivos mínimos para instalar el paquete. Esta carpeta es al mismo tiempo un projecto de RStudio, es es porque estamos usando usethis y RStudio y viene con todas las ventajas que vimos. Sin embargo, no es impresindible que un paquete sea un proyecto al mismo tiempo.\n\nfs::dir_tree(\"C:/Users/tonin/Documents/Courses/paqueteprueba/\", all = TRUE)\n\nC:/Users/tonin/Documents/Courses/paqueteprueba/\n├── .gitignore\n├── .Rbuildignore\n├── .Rproj.user\n├── DESCRIPTION\n├── NAMESPACE\n├── paqueteprueba.Rproj\n└── R\nAdemás del los archivos DESCRIPTION, NAMESPACE y la carpeta R que ya presentamos, hay algunos archivos y carpetas ocultas. Conocés el .gitignore, pero .Rbuildignore y .Rproj.user son nuevos. El primero es parecido a .gitignore, incluye la lista de archivos y carpetas que R deberá ignorar al momento de construir el paquete, por ahora la lista es corta pero ira creciendo a medida que sumemos cosas al paquete. La carpeta .Rproj.user es algo que está en todo projecto de RStudio e incluye las configuraciones específicas del proyecto.\n\n10.5.1 Control de versiones en el desarrollo de paquetes\nSi bien es posible desarrollar un paquete de R sin utilizar git y GitHub, vale la pena el esfuerzo extra. Entre otras razones que tienen que ver con las ventajas del control de versiones, GitHub es una de las principales maneras de compartir software y en particular, paquetes de R.\nPreviamente vimos como crear un repositorio desde GitHub y asociarlo a un repositorio local. En esta sección usaremos funciones de usethis para automatizar esas tareas.\n\n10.5.1.1 Repositorio local\nPara crear el repositorio local usaremos usethis::use_git(). Es importante correr la función en la consola y asegurarnos que el proyecto de R esté abierto (aparece el nombre en la esquina superior derecha de RStudio) para asegurarnos que el repositorio local esté asociado a nuestro paquete.\nusethis::use_git()\nEsta funcion va a crear el repositorio y generara un commit inicial de todos los archivos que estén presentes en el proyecto. Va a preguntarte si queres hacer esto. Contestale que si seleccionado la opción afirmativa. Luego va a preguntarte si queres reiniciar RStudio. Esto es necesario para que aparezca la pestaña de Git desde la cual podremos trabajar sobre el repositorio. Seleccioná la opción afirmativa, ojo que siempre cambia el orden!\n&gt; usethis::use_git()\n✔ Setting active project to \"/ubicacion/de/tu/proyecto\".\n✔ Initialising Git repo.\n✔ Adding \".Rproj.user\", \".Rhistory\", \".Rdata\", \".httr-oauth\", \".DS_Store\", and \".quarto\" to\n  .gitignore.\nℹ There are 2 uncommitted files:\n• .gitignore\n• test.Rproj\n! Is it ok to commit them?\n\n1: Negative\n2: Yup\n3: Nope\n\nSelection: 2\n✔ Adding files.\n✔ Making a commit with message \"Initial commit\".\nA restart of RStudio is required to activate the Git pane.\nRestart now?\n\n1: Absolutely not\n2: No\n3: Yes\n\nSelection: 3\n\n10.5.1.2 Repositorio remoto en GitHub\nPodemos crear el repositorio remoto desde RStudio corriendo usethis::use_github() desde la consola.\n&gt; usethis::use_github()\nEsta funcion hace lo siguiente:\n\nCrea un nuevo repositorio en GitHub con el nombre del proyecto.\nConfigura ese nuevo repositorio como origen remoto para el repositorio local.\nConfigura tu branch local por defecto para realizar el mismo seguimiento en el origen y realiza un push inicial.\nAbre el nuevo repositorio en tu navegador.\n\nLa función devolverá algo similar a esto en la consola:\n✔ Creating GitHub repository \"paocorrales/paqueteprueba\".\n✔ Setting remote \"origin\" to \"https://github.com/paocorrales/paqueteprueba.git\".\n✔ Adding \"https://github.com/paocorrales/paqueteprueba\" to URL. \n✔ Adding \"https://github.com/paocorrales/paqueteprueba/issues\" to BugReports. \nℹ There is 1 uncommitted file: • DESCRIPTION !\n\nIs it ok to commit it?\n\n1: Absolutely not \n2: Not now \n3: Yes\n\nSelection: 3 \n\n✔ Adding files. \n✔ Making a commit with message \"Add GitHub inks to DESCRIPTION\". \n✔ Pushing \"master\" branch to GitHub and setting \"origin/master\" as upstream branch. \n✔ Opening URL &lt;https://github.com/paocorrales/paqueteprueba&gt;.\nY con esto ya podes empezar a trabajar en el paquete.\n\n10.5.2 Completando el archivo DESCRIPTION\nEl archivo DESCRIPTION contiene los metadatos del paquete paquete y algunos parámetros de configuración que R utiliza al construirlo e instalarlo. El formato de los metadatos utiliza el patrón key: value. Así, por ejemplo, la clave Package tiene el valor paqueteprueba, que le dice a R cuál es el nombre del paquete. Asimismo, Title y Authors proporcionan un poco más de información sobre lo que hace el paquete y quién lo creó. Un archivo DESCRIPTION completo tiene muchas otros campos, alguns de los cuales no son importantes ya que son creadas automáticamente y usados internamente por R para propósitos generales durante la construcción del paquete. Otros, son bastante importantes. Específicamente, las claves Title, Authors, y Description deberían tener más valores más apropiados.\nLos campos Title y Description describen lo que hace el paquete. Sólo se diferencian en la longitud:\n\nEl título es una descripción del paquete en una línea, y a menudo se muestra en listados de paquetes. Debe ser texto plano (sin marcas), cada palabra en mayúsculas como un título, y NO terminar en un punto. Se breve: los listados suelen truncar el título a 65 caracteres.\nLa descripción es más detallada que el título. Puede utilizar varias frases, pero está limitado a un párrafo. Si la descripción abarca varias líneas (y así debe ser), cada una de ellas no debe superar los 80 caracteres. Deje 4 espacios entre las líneas siguientes.\n\nPor ejemplo el título y la descripción de ggplot2 tienen esta pinta:\nTitle: Create Elegant Data Visualisations Using the Grammar of Graphics\nDescription: A system for 'declaratively' creating graphics,\n    based on \"The Grammar of Graphics\". You provide the data, tell 'ggplot2'\n    how to map variables to aesthetics, what graphical primitives to use,\n    and it takes care of the details.\nEl campo Authors@R se utiliza para identificar al autor o autora del paquete, y a quién contactar si algo no funciona. Este campo es inusual porque contiene código R en lugar de texto plano. Este es un ejemplo:\nAutores@R: person(\"Paola\", \"Corrales\", email = \"mimail@pao.com\",\n  role = c(\"aut\", \"cre\"))\nEstamos usando la función person() que viene con R base en el paquete utils.\n\nperson(\"Paola\", \"Corrales\", email = \"mimail@pao.com\",\n  role = c(\"aut\", \"cre\"))\n\n[1] \"Paola Corrales &lt;mimail@pao.com&gt; [aut, cre]\"\n\n\nEsta función dice que Paola Corrales está a cargo de mantener el paquete (cre) y es autora (aut) y que su dirección de correo electrónico es mimail@pao.com. Es posible listar a más de una persona en este campo. La función person() tiene cuatro argumentos principales:\n\nEl nombre, especificado por los dos primeros argumentos, given y family. En la cultura occidental, given (nombre) va antes que family (apellido). En muchas otras culturas, esta convención no es válida. Para agregar una entidad, empresa u organización, como “R Core Team” o “Posit Software, PBC”, se usa el argumento given (y se omite family).\nLa dirección de email, es solo un requisito para quien mantiene el paquete. Es importante que uses una dirección de correo electrónico a la que tengas acceso permanente. La política de CRAN requiere que sea para una persona, en lugar de, por ejemplo, una lista de correo.\n\nUno o más códigos de tres letras especificando el role. Estos son los roles más importantes que hay que conocer:\n\ncre: quien mantiene le paquete y la persona a la que deberías molestar si tenés problemas usandolo. A pesar de ser la abreviatura de «creator», este es el rol correcto para el mantenedor, incluso si no es la persona que inicialmente creó el paquete.\naut: autores, aquellas personas que han hecho contribuciones significativas al paquete.\nctb: contribuidores, aquellas personas que han hecho contribuciones menores, como parches.\ncph: titular de los derechos de autor. Se utiliza para listar titulares de copyright adicionales que no son autores, normalmente empresas, como un empleador de uno o más de los autores.\nfnd`: financiador, las personas u organizaciones que han proporcionado apoyo financiero para el desarrollo del paquete.\n\n\nEl argumento opcional comment se usa para incluir el identificador de ORCID. Y es particularmente útil en el ámbito académico.\n\n\nEs momento de empezar a darle forma al paquete.\n\nSi aún no seguiste las instrucciones para crear el paqueteprueba, es el momento. No te preocupes por el nombre, este paquete es solo para practicar.\nAbrí el projecto/paquete.\nAbrí el archivo DESCRIPTION y completá los campos Title, Authors, y Description",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#flujo-de-trabajo-para-el-desarrollo-de-paquetes",
    "href": "09_paquetes-1.html#flujo-de-trabajo-para-el-desarrollo-de-paquetes",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.6 Flujo de trabajo para el desarrollo de paquetes",
    "text": "10.6 Flujo de trabajo para el desarrollo de paquetes\nAunque hay varias formas de desarrollar un paquete R, un flujo de trabajo bien establecido y documentado gira en torno a hacer uso de usethis y devtools.\nLos pasos típicos utilizados en este flujo de trabajo de desarrollo son:\n\nCuando tengas una idea de una función o conjunto de funciones similares, por por ejemplo, sumar 2 números, es momento de iniciar un nuevo script. Para eso escribí en la consola usethis::use_r(\"suma\"). Se creará un nuevo archivo R en la carpeta R/ y se abrirá en RStudio.\nEn este nuevo archivo podrás empezar a crear y desarrollar la función, escribiendo los argumentos de entrada y la eventual salida. Por ahora llegamos hasta acá pero pronto veremos como documentar la función.\nUna vez que sienta que la función está lista para ser probada, podés probar la función ejecutándola en el mismo script, en la consola o en un archivo R Markdown. La otra alternativa para que la función esté disponible para R, es cargarla con Ctrl-Shift-L que ejecuta el comando load_all() (de devtools). Esto solo funciona porque estamos desarrollando un paquete.\nA menos que la función que creaste sea muy simple es muy improbable que funcione perfectamente la primera, lo más probable es que la función exactamente como esperabas o de un error. En ese caso tendrás que modificarla, cargarla nuevamente con load_all() y probarla nuevamenta tantas veces como sea neceasario hasta conseguir los resultados que necesitas. función.\n\nVamos a probar un poco de este flujo de trabajo haciendo una función de práctica. En la consola, escribí esta función:\n\nusethis::use_r(\"funcion_prueba\")\n\nA continuación se abrirá el recientemente creado archivo R/funcion_prueba.R. Escribí la función y guardá los cambios en el archivo.\n\nsuma &lt;- function(x, y) {\n  x + y\n}\n\nAntes de hacer nada, escribe suma(2, 2) en la Consola y apretá enter para ejecutarlo. ¿Qué ocurre? Nada. Eso es porque R no sabe que la función existe. Tenemos que hacer que R la conozca ya sea ejecutando la función directamente desde el script (Ctrl-Enter para enviar a la Consola), usando source() en el script, instalando el paquete, o imitando la instalación del paquete con la función load_all(). Como estamos desarrollando un paquete usaremos la función load_all().\nVamos a probar la función load_all() con el atajo Ctrl-Shift-L. Ahora si, volvé a escribir suma(2, 2) en la consola. Ahora deberías ver que funciona.\nEl flujo de trabajo para el desarrollo de funciones en un paquete tiene entonces esta pinta:\n\n\nFlujo de trabajo para el desarrollo de una función.\n\n\nPractiquemos el flujo de trabajo\nYa que usarás este flujo de trabajo cuando hagas paquetes en R, es hora de que lo practiques.\nRealiza los siguientes cambios en la función. Con cada cambio, vuelva a cargarla (Ctrl-Shift-L en RStudio o load_all() en la Consola) para que las funciones actualizadas estén disponibles. Después de cada cambio probá que la función haga lo que debe hacer.\n\nAgregá valores por defecto para los argumentos x e y. Probá correr la función sin pasarle argumentos: suma().\nModificá la función para que chequee que los argumentos sean numéricos. Probá la función con suma(\"1\", 1)\nModifica nuevamente la función para que si x o y son negativos, la función devuelva “No puedo sumar negativos”.\n\n\n\n10.6.1 Datos en paquetes\nMuchos paquetes de R incluyen datos, en algunos casos porque son útiles para mostrar como usar las funciones que incluye, en otros casos porque es el objetivo principal de ese paquete. El paquete datos es el mejor ejemplo de esto último.\nEn la mayoría de los casos los datos en el paquete estarán disponibles para que las personas los usen. Guardaremos estos datos en la carpeta /data y el flujo de trabajo usando usethis tendrá esta pinta:\n# Leer datos desde algún archivo\n# o generar datos\n\n# Manipular los datos para que tengan la pinta que necesitamos\n\ndatos &lt;- sample(1000)\nusethis::use_data(datos)\nLa función nos devolverá lo siguiente:\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'datos' to 'data/datos.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nEs decir, automáticamente crea la carpeta y guarda los datos con formato .rds (un tipo de archivo específico de R). En principio el código de arriba solo se correrá una vez a menos que sea necesario actualizar los datos. Sin embargo es una buena idea guarda el código y los datos crudos si los hubiera en data_raw. Esta carpeta además no debe incluirse cuando se construye el paquete por lo que hay que agregarla a Rbuildignore.\nAhora si apretamos Ctrl-Shift-L para cargar de nuevo el paquete de prueba y escribimos datos en la consola veremos los datos que creamos.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "09_paquetes-1.html#ex-paquete",
    "href": "09_paquetes-1.html#ex-paquete",
    "title": "\n10  Empaquetando funciones\n",
    "section": "\n10.7 Construyendo un paquete de R paso a paso",
    "text": "10.7 Construyendo un paquete de R paso a paso\n\nEs hora de empezar a unir lo que hicimos. El objetivo de este ejercicio es crear la estructura de un paquete que lean y analice datos de estaciones meteorológicas. Pero además este será un trabajo colaborativo entre 2 personas para practicar como desarrollar software en equipo usando GitHub.\nCrear el paquete\n\nPiensen un nombre para el paquete, debe seguir las reglas pero no importa si se repite en otro ámbito.\nEl paquete debera estar en la cuenta de GitHub de una de las personas que integran el grupo. Decidan quien sera y realicen los siguientes pasos en la computadora de esa persona.\nCreen la estructura del paquete con usethis.\nModifiquen el archivo DESCRIPTION con todo lo necesario.\n\nConectarlo con Git localmente\n\nPara crear el repositorio local usá la función de usethis correspondiente.\n\nCrear el repo remoto en GitHub\n\nCon el proyecto del paquete abierto en RStudio en la computadora de la persona que tendra el repo en GitHub debe correr la función de usethis que genera el repositorio remoto.\n\nModificar la configuración del repositorio en GitHub para que la otra persona del grupo tenga los permisos necesarios para hacer commits y push. Necesitarás sabes su nombre de usuario.\n\nEn GitHub.com, navega a la página principal del repositorio.\n\nHacé clic en Settings.\n\n\nCaptura de pantalla de un encabezado de repositorio en el que se muestran las pestañas. La pestaña “Configuración” está resaltada con un contorno naranja oscuro.\n\n\nEn la sección “Access” de la barra lateral, haz clic en Colaborators.\nHacé clik en el botón verde Add people.\nComenzá a teclear el nombre de la persona que deseas invitar dentro del campo de búsqueda hasta que aparezca.\nHacé clikc en Add NOMBRE to this repository.\nLa persona recibirá un correo electrónico invitándole al repositorio. Una vez que acepte la invitación, tendrá acceso de colaborador a tu repositorio.\n\n\nLa otra persona del grupo ahora puede clonar el repo en su computadora, siguiendo los pasos que vimos cuando trabajaron individualmente con git y Github.\nModificá el README.md para indicar que el paquete es de prueba, que no está pensado para ser usado como tal.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Empaquetando funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html",
    "href": "10_documentacion.html",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "",
    "text": "11.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#objetivos-de-aprendizaje",
    "href": "10_documentacion.html#objetivos-de-aprendizaje",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "",
    "text": "Describir el propósito de documentar código y paquetes\nDocumentar funciones con roxygen2\n\nCrear un README y una viñeta para la documentación de paquetes\nCrear la web del paquete",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#por-qué-necesitamos-documentación",
    "href": "10_documentacion.html#por-qué-necesitamos-documentación",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.2 ¿Por qué necesitamos documentación?",
    "text": "11.2 ¿Por qué necesitamos documentación?\nIgual que el control de versiones rastrea qué cambios haces y por qué, la documentación del código y de los paquetes informa a las personas en tu equipo y futuras y futuros usuarios lo que hace el código y por qué.\nCon el tiempo, los lenguajes de programación se han hecho más “legibles para el ser humano”: una persona con mucha experinecia podría leer el código y entender lo que hace. Pero aunque entienda lo que hace el código, puede que no sea obvio por qué lo hace. Los lenguajes de programación vienen con herramientas incorporadas para agregar comentarios y documentación que no son leídos por la computadora, sino que existen únicamente para ayudarte a vos y otras personas a describir y comprender el código. Una buena documentación es clave para la apertura, la reproducibilidad y la sostenibilidad del proyecto.\nLa buena documentación se da en todas las escalas del código: a nivel de objetos individuales, funciones y test, así como de todo el paquete. En este capítulo, describimos el flujo de trabajo de la documentación de un paquete como parte de su desarrollo y esbozamos los componentes de un paquete bien documentado.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#documentación-de-funciones",
    "href": "10_documentacion.html#documentación-de-funciones",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.3 Documentación de funciones",
    "text": "11.3 Documentación de funciones\nLa documentación de funciones en R es posiblemente la más usada y accesible. Podemos revisarla con ?unafuncion o help(\"unafuncion\") y para quienes les gusta los atajos de teclado, con F1 si el cursor está en el nombre de la función. R Base proporciona una forma estándar de documentar un paquete donde cada función se documenta en un tema o topic, un archivo .Rd (“R documentation”) en el directorio man/. Si bien los archivos .Rd utilizan una sintaxis basada en LaTeX no es necesario aprenderla ya que el paquete roxigen2 hace gran parte del trabajo.\nLa mayor ventaja es que podemos escribir la documentación en el mismo archivo .R y dejarle la tarea de generar los archivos .Rda roxigen2.\n#' Suma dos números\n#' \n#' Suma dos números .\n#'\n#' @param x Un número.\n#' @param y Un número.\n#'\n#' @returns Un vector numérico.\n#'\n#' @examples\n#' suma(1, 1)\n#' suma(10, 1)\n#'\n#' @export\nsuma &lt;- function(x = 2, y = 2) {\n  x + y\n}\nLa manera en que veamos esta documentación depende de donde estemos ya que los archivos .Rd son la base de lo que vemos en la pestaña help de RStudio, los pdf de cada paquete, su página web, etc.\n\nSe puede insetar un esqueleto de la documención, para eso nos paramos sobre la definición de la función y vamos a Code &gt; Insert roxygen skeleton en RStudio. Este comando añade los componentes por defecto de la función para no empezar a escribir la documentación desde cero.\n\nAsí es como se ve la documentación de nuestra función suma().\n\nEn resumen hay cuatro pasos en el flujo de trabajo básico de roxygen2:\n\nAgregar comentarios de roxygen2 a losr archivos .R de funciones.\nEjecutar devtools::document() o Ctrl/Cmd + Mayús + D para convertir los comentarios de roxygen2 en archivos .Rd.\nRevisá la documentación con ?function.\nModificá y repetí hasta que la documentación tenga el aspecto que necesites.\n\n\n\n11.3.1 Sintaxis de roxigen2\nAhora si podemos ver en detalle como suar roxigen2. Lo primero que habrás notado es que todas las líneas de la documentación comienzan con #'. Además algunas líneas tienen este patrón: @tagname tagvalue. Es decir, una etiqueta y un valor asociado, por ejemplo @param es una etiqueta y x es el valor asociado. Otra etiqueta importante es @export que es la que indica que la función se exporta, es decir, queda disponible para que pueda usarse al cargar el paquete.\n\n11.3.1.1 Título, descripción, detalles\nLa introducción de la documentación incluye un título, una descripción y, opcionalmente, detalles de la función. Aunque es posible utilizar etiquetas explícitas en la introducción, solemos utilizar etiquetas implícitas cuando es posible:\n\nEl título se genera con la primera frase. Debe escribirse en mayúsculas, sin punto final y seguido de una línea en blanco. El título se muestra en varios índices de funciones (por ejemplo, help(paquete = «algúnpaquete»)) y es lo que una persona suele ver cuando navega por varias funciones.\nLa descripción se genera con el párrafo siguiente. Se muestra en la parte superior de la documentación y debe describir brevemente las características más importantes de la función. Escribir la descripción puede resultar difícil en el caso de funciones sencillas, ya que puede parecer que se está repitiendo el título de la función. Intentá encontrar otra manera de describir la función si es posible.\nLos detalles adicionales son cualquier cosa después de la descripción. Los detalles son opcionales, pero pueden ser de cualquier longitud, por lo que resultan útiles para profundizar en algún aspecto importante de la función. Tené en cuenta que, aunque los detalles vienen justo después de la descripción en la introducción, aparecen mucho más adelante en la documentación renderizada.\n\n11.3.1.2 Argumentos\nDocumentar los argumentos de la función es probablemente la mayor parte del trabajo. Para esto vamos a usar la etiqueta @param (que viene de parámetro, otra manera de decir argumento). Es necesario documentar todos los argumentos en el orden en el que aparecen en la función.\nLa documentación de cada argumento incluye una descripción breve del imput permitido y que rol cumple en la función. Por ejemplo, estos son los argumentos de la función sd()\n#' @param x a numeric vector or an **R** object but not a [factor] coercible to numeric by `as.double(x)`.\n#' @param na.rm logical. Should missing values be removed?\nMencionan que tipo de objeto requiere cada uno y una descripción. Es recomendable también mencionar cual es el valor por defecto si lo tiene y si el argumento es opcional.\nCuando 2 o más argumentos están muy relacionados (por ejemplo en la función suma()) es recomendable documentarlos juntos de la siguiente manera:\n#' @param x,y Un par de valores numéricos.\n\n11.3.1.3 Resultado\nDocumentar el resultado de una función es tan importante como documentar sus argumentos. Para esto usamos la etiqueta @return y aparece en la documentación bajo el título Value. Aquí la prioridad es describir la forma general del resultado, es decir, qué tipo de objeto es y sus dimensiones (si eso tiene sentido). Por ejemplo, si la función devuelve un vector, describiremos de que tipo y su longitud, o si devuelve un data.frame, se puede describir los nombres y tipos de las columnas y el número previsto de filas.\nPor ejemplo esta es la sección correspondiente para la función read_csv() :\n#' @return\n#' A [tibble()]. If there are parsing problems, a warning will alert you. You can retrieve the full details by calling [problems()] on your dataset.\n\n11.3.1.4 Ejemplos\nEsta sección de la documentación es importantísima porque le permite a cualquier nuevo usuario entender en detalle como funciona la función. Usaremos la etiqueta @examples (en plural!).\nEl principal dilema de los ejemplos es que deben satisfacer dos requisitos al mismo tiempo:\n\nEl código de ejemplo debe ser legible y realista.\nEl código de ejemplo debe ejecutarse sin errores.\n\nUsamose ejemplos para mostrar en primer lugar el funcionamiento básico de la función y, a continuación, para destacar las propiedades más importantes. Intentá centrarte en las aplicaciones más importantes sin entrar en todos los detalles. Si te encontrás escribiendo ejemplos muy largos es posible que sea hora de revisarlos.\n\n11.3.2 Documentar datos\nLos datos que forman parte del paquete también deben documentarse. Documentar datos es como documentar una función con algunas pequeñas diferencias. En lugar de documentar los datos directamente, se documenta el nombre del conjunto de datos y se guarda en un archivo .R en la carpeta R/. Por ejemplo, el bloque roxygen2 utilizado para documentar los datos de pingüinos tiene este aspecto:\n#' Medidas de tamaño de pingüinos adultos en busca de comida cerca de la estación Palmer en la Antártica.\n#' \n#' Incluye medidas para: especie de pingüino, isla dentro del Archipiélago de Palmer, tamaño (largo de aleta, masa corporal, dimensiones de pico) y sexo.\n#' \n#' @format Un tibble con 344 filas y 8 variables\n#' \n#'\\describe{\n#'  \\item{especie}{un factor que indica la especie de pingüino (Adelia, Barbijo y Papúa)}\n#'  \\item{isla}{un factor que indica la isla en el archipiélago de Palmer (Biscoe, Dream o Torgersen)}\n#'  \\item{largo_pico_mm}{un número que indica el largo del pico (milímetros)}\n#'  \\item{alto_pico_mm}{un número que indica el alto del pico (milímetros)}\n#'  \\item{largo_aleta_mm}{un entero que indica el largo de la aleta (milímetros)}\n#'  \\item{masa_corporal_g}{un entero que indica la masa corporal (gramos)}\n#'  \\item{sexo}{un factor que indica el sexo del pingüino (hembra, macho)}\n#'  \\item{anio}{un entero que indica el año estudiado (2007, 2008 o 2009)}\n#'}\n#'\n#'@source Pingüinos Adelia: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Adélie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f. \n#'\n\"pinguinos\"\n\n\nElegí al menos una de las funciones que creaste durante la sección funciones.\nAgregala al paquete de prueba en un nuevo archivo .R usando el flujo de trabajo que vimos.\nDocumentá la función y practicá el flujo de documentación: Ctrl+Shif+D para documentar y luego Ctrl+Shif+L para cargar el paquete, revisar la documentación y mejorarla",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#viñetas",
    "href": "10_documentacion.html#viñetas",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.4 Viñetas",
    "text": "11.4 Viñetas\nTodo lo que hemos dicho hasta ahora sobre la documentación se aplica a todos los proyectos de programación en casi cualquier lenguaje. Las “viñetas”, en cambio son un tipo de documentación distintivo de R: describen en gran detalle algún aspecto de tu paquete con ejemplos de uso y explicaciones detalladas.\nLa función browseVignettes() te permite explorar las viñetas existentes en los paquetes que tenés instalados. Si corrés la función sin argumentos se abrirá una ventana de en tu navegador con una lista de las viñetas disponibles, mientras que browseVignettes(\"nombrepaquete\") mostrará las viñetas de un paquete concreto. También podés llamar directamente a una viñeta si conoces su nombre con vignette(\"vignettename\") que se mostrará en la pestaña help.\n\nbrowseVignettes(\"tidyr\")\nvignette(\"nest\")\n\nLas viñetas también aparecerán como artículos en la página web del paquete (que aprenderemos a crear al final de esta sección), esta es una gran manera de consultarlas porque no requiere la instalación del paquete o correr su código. Por ejemplo en este link se encuentra la misma viñeta de tidyr que vimos recién.\n\n11.4.1 Crear una viñeta\nUna vez más, usethis tiene una función útil para ayudarnos a crear viñetas. La función usethis::use_vignette() toma el título de la viñeta y crea un breve documento R Markdown a modor de plantilla en la carpeta vignettes/.\nAdemás añade las dependencias necesarias a DESCRIPTION, es decir, añade knitr al campo VignetteBuilder y añade tanto knitr como rmarkdown a Suggests (veremos más sobre dependencias en la próxima sección). Y también añade patrones a .gitignore para garantizar que los archivos creados como efecto secundario de la previsualización de tus viñetas se mantengan fuera del repositorio.\nSumemos una viñeta a nuestro paquete de prueba:\n\nusethis::use_vignette(\"viñeta_prueba\")\n\nY de paso agreguemos algo de contenido, por ejemplo como usar la función suma().\n---\ntitle: \"viñeta_prueba\"\noutput: rmarkdown::html_vignette\nvignette: &gt;\n  %\\VignetteIndexEntry{viñeta_prueba}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\"\n)\n```\n\n```{r setup}\nlibrary(paqueteprueba)\n```\n\nEsta es una viñeta de prueba. Podemos mostrar como usar la función `suma()`\n\n```{r}\nsuma(2, 2)\n```\nNormalmente, kniteariamos este archivo bastante seguido para ver como va quedando la viñeta, sin embargo, si intentamos hacer eso ahora nos dará un error “No existe el paquete ‘paqueteprueba”’. Esto puede parecerte raro porque estamos creando el paquete, claro que existe! Pero, resulta que crear la documentación y cargarlo con Ctrl+Shif+L no es suficiente, necesitamos instalarlo.\nComo estamos en el contexto de desarrollar el paquete, la instalación no se hace con install.packages(). Necesitamos instalar el paquete usando el mismo código fuente que estamos desarrollando y para eso podemos usar el atajo de teclado Ctrl+Shif+B (que viene de build o construir en inglés).\nAhora si, podremos knitear nuestra viñeta que por ahora esbastante corta:\n\nUna vez que tengas el borrador de la viñeta, el flujo de trabajo es sencillo:\n\nEmpezá a añadir fragmentos de texto y código a la viñeta. Probá el código para asegurarte de que corra y genere los resultados que querés mostrar.\nKnitea toda la viñeta periódicamente.\nRepetí los pasos hasta que la completes.\n\nAl trabajar con el formato RMarkdown se puede hacer uso de markdown para dar formato al texto y contenido.\nAl escribir una viñeta, estás enseñando a alguien a utilizar tu paquete. Tenés que ponerte en el lugar de quien la leerá y asumilar que esa persona es novata. Esto puede resultar difícil, porque es fácil olvidar todos los conocimientos que ya se han interiorizado y todas las desiciones que tomaste sobre tu paquete. Te recomendamos que le pidas a alguien más leer la viñeta y te de feedback para mejorarla.\n\nCompletá la viñeta del paquete de prueba\nSi hiciste el ejercicio anterior, nuestro paquete de prueba ahora no solo tiene la función suma(), tiene varias más.\nCompletá la viñeta agregando ejemplos y explicaciones sobre como se usan las funciones y para que sirven.\nNo te olvides de knitear para ver el resultado.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#readme",
    "href": "10_documentacion.html#readme",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.5 README",
    "text": "11.5 README\nEl README es es la puerta de entrada a tu paquete, incluye las instrucciones sobre cómo instalarlo y ejemplos de cómo utilizarlo.\nLa función usethis::use_readme_rmd() crea un documento R Markdown con algunas secciones y texto estándar que podemos usar como base para crear un documento útil y descriptivo.\n\nuse_readme_rmd()\n\n\nR Markdown vs. Mardown\nLee la ayuda de use_readme_rmd() y use_readme_md(). ¿Qué diferencias hay entre archivos .Rmd y .md? ¿Por qué usarías uno u otro para el README?\n\nGitHub trata al archivo README.md de forma especial, mostrándolo en la pestaña principal del repositorio. El README creado por use_readme_rmd() entonces, debe ser kniteado antes de subirlo al repositorio remoto.\nEl encabeza YAML que incluye el README output: github_document indicará a knitr que cree una salida Markdown para GitHub en lugar del HTML por defecto. Para esto podés usar el botón Knit en el menú situado encima del editor, o ejecutá devtools::build_readme() en la consola.\n\nEdita y knitea el README del paquete de prueba\n\nEditá README.Rmd para incluir una descripción del paquete de prueba, su instalación y un ejemplo de su uso.\nkniteá el README.Rmd para que crea la salida README.md.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#website",
    "href": "10_documentacion.html#website",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.6 Website",
    "text": "11.6 Website\nEn este punto nuestro paquete de prueba tiene sus funciones documentadas, incluye una viñeta que detalla el uso de las funciones y un README con la información más importante que necesita cualquier persona para comenzar a usarlo.\nEl objetivo ahora es construir una página web para el paquete de manera programática usando todo lo anterior. Para esto usaremos el paquete pkgdown. Para darte una idea de lo que estamos hablando podés visitar la pagína web del paquete pkgdown: https://pkgdown.r-lib.org/.\nSi al ver el ejemplo asumiste que esto lleva muchísimo tiempo, la realidad no podría ser más diferente. Con un par de funciones podemos tener una página web funcionando. La primera función es por supuesto de usethis:\n\nusethis::use_pkgdown()\n\nAl ejecutar esta función veremos algo así:\n✔ Setting active project to 'C:/Users/tonin/Downloads/paqueteprueba'\n✔ Adding '^_pkgdown\\\\.yml$', '^docs$', '^pkgdown$' to '.Rbuildignore'\n✔ Adding 'docs' to '.gitignore'\n✔ Writing '_pkgdown.yml'\n• Modify '_pkgdown.yml'\nLa función hace todo lo siguiente:\n\nCrea _pkgdown.yml, el archivo de configuración principal de la web. Podrías revisar este archivo y cambiar cosas pero no hay necesidad inmediata de cambiar o añadir nada.\nAñade varios archivos a .Rbuildignore, para evitar que algunos archivos y directorios específicos de pkgdown se incluyan en tu paquete.\nAñade docs, el destino por defecto para un sitio renderizado, a .gitignore. Hacemos esto porque esperamos que la web definitiva se construya y publique usando GitHub Actions y Pages. Esto significa que el sitio web renderizado en docs/ sólo sirve como vista previa local.\npkgdown::build_site() es una función a la que llamarás repetidamente, para volver a renderizar tu sitio localmente.\n\nAdemás de revisar la web de esta manera también es posile hacer click en el archivo docs/index.html en el explorador.\n\nUna GitHub Action o “acción” de GitHub es un script que corre directamente en GitHub y puede cumplir muchas funciones. Se pueden construir a mano o aprovechar las plantillas que ya existen.\nEstas acciones además pueden programarse para que se ejecuten de manera automática en un determinado horario, cada vez que se hace un commit al repositorio remoto o en otras circunstancias.\n\nPara publicar la web necesitamos hacer commits y push al repositorio remoto. A continuación, una “acción” de GitHub construirá y publicará la web en una url con nombre &lt;nombreusuario&gt;.github.io/&lt;nombrepaquete&gt;. Los pasos para llegar a este punto son varios y si bien se pueden hacer a mano vamos a usar una función de usethis para automatizar todo.\n\nusethis::use_pkgdown_github_pages()\n\n✔ Writing '_pkgdown.yml'\n• Modify '_pkgdown.yml'\n✔ Initializing empty, orphan 'gh-pages' branch in GitHub repo paocorrales/paqueteprueba'\n✔ GitHub Pages is publishing from:\n• URL: 'https://paocorrales.github.io/paqueteprueba/'\n• Branch: 'gh-pages'\n• Path: '/'\n✔ Creating '.github/'\n✔ Adding '^\\\\.github$' to '.Rbuildignore'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/pkgdown.yaml@v2' to '.github/workflows/pkgdown.yaml'\n• Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\n✔ Recording 'https://paocorrales.github.io/paqueteprueba/' as site's url in '_pkgdown.yml'\n✔ Adding 'https://paocorrales.github.io/paqueteprueba/' to URL\n✔ Setting 'https://paocorrales.github.io/paqueteprueba/' as homepage of GitHub repo 'paocorrales/paqueteprueba'\nVeamos qué hace realmente use_pkgdown_github_pages():\n\nInicializa una rama vacía en tu repositorio de GitHub, llamada gh-pages (por “GitHub Pages”). La rama gh-pages sólo vivirá en GitHub (no hay razón para crearla en tu repositorio local) y representa una versión paralela del paquete. Los únicos archivos rastreados en gh-pages son los que constituyen el sitio web de tu paquete (los archivos que ves localmente en la carpeta docs/).\nActiva GitHub Pages en el repositorio y le dice que aloje un sitio web desde los archivos encontrados en la rama gh-pages.\nCopia el archivo de configuración de la GitHub Action que hace construye y publica la web. El archivo aparece en tu paquete como .github/workflows/pkgdown.yaml.\nAñade la URL de tu sitio como página de inicio de tu repositorio de GitHub.\nAñade la URL de tu sitio a DESCRIPTION y _pkgdown.yml.\n\nDespués de ejecutar con éxito use_pkgdown_github_pages(), deberías poder visitar el nuevo sitio en la url.\n\nPara seguir mejorando la web y darle un estilo propio te recoemndamos leer las viñetas del paquete pkgdown arrancando por Customise your site.\n\n\nSi aún no lo hiciste, es hora de crear la web del paqueteprueba con el que venimos trabajando.\nEs posible que al hacerlo encuentres cosas para mejorar en el README o en la documentación de alguna de las funciones. En ese caso modificá los archivos necesarios y seguí el flujo de trabajo que vimos antes de hacer commit y push al repositorio remoto. Esto es:\n\nSi cambias la documentación: Usá Ctrl+Shift+D para construir la documentación de nuevo.\nSi cambiás cosas en el README: knitea el archivo .Rmd para generar el .md.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "10_documentacion.html#ex-doc",
    "href": "10_documentacion.html#ex-doc",
    "title": "\n11  Documentando paquetes y funciones\n",
    "section": "\n11.7 Construyendo un paquete de R paso a paso",
    "text": "11.7 Construyendo un paquete de R paso a paso\n\nA esta altura seguramente ya te imaginás que sigue. Es hora de generar la documentación del paquete que lee y analiza datos meteorológicos (¿ya tiene nombre?).\nDe nuevo, esto es un trabajo en equipo por lo que esperamos ver aportes (commits) de ambos miembros del equipo. Pueden dividirse el trabajo: cada persona documenta algunas funciones, alguien se ocupa del README, alguien de la viñeta, etc.\nRecomendaciones:\n\nSiempre arranquen a trabajar haciendo un pull para actualizar la versión del repo local con el remoto.\nNo modifiquen archivos que la otra persona está usando. Si hacen esto, al hacer commits habrá problemas para mergear tu versión y la de tu compañere.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Documentando paquetes y funciones</span>"
    ]
  },
  {
    "objectID": "11_errores.html",
    "href": "11_errores.html",
    "title": "\n12  Dependencias y tests\n",
    "section": "",
    "text": "12.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#objetivos-de-aprendizaje",
    "href": "11_errores.html#objetivos-de-aprendizaje",
    "title": "\n12  Dependencias y tests\n",
    "section": "",
    "text": "Identificar las dependencias del paquete y registrarlas en DESCRIPTION.\nAñadir pruebas (tests) de una función del paquete usando testthat.\nEjecutar todos los tests del paquete.\nDescribir que resultado se espera de una función y usar la familia expect_xxx() en tests.\nRevisar la cobertura de los test y definir cuando es necesario agregar nuevos.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#dependencias",
    "href": "11_errores.html#dependencias",
    "title": "\n12  Dependencias y tests\n",
    "section": "\n12.2 Dependencias",
    "text": "12.2 Dependencias\nExiste una dependencia cuando tu paquete utiliza funcionalidad de otro paquete (u otra herramienta externa). Por ejemplo, si una función de tu paquete usa mutate(), entonces dplyr es una dependencia de tu paquete. Esto implica, entre otras cosas, que una persona necesita instalar dplyr antes de poder usar las funciones de tu paquete.\nEstas dependencias deben incluirse en el archivo DESCRIPTION. En general, éstos van en una sección llamada “Imports”, lo que asegura que momento de instalar el paquete también se instalen las dependencias (si es que no están ya instaladas). También existe la sección “Suggests”, en donde se pueden listar paquetes que no son esenciales para que tu paquete funcione. Por ejemplo, una función que utiliza un método estadístico disponible en R base o una versión más eficiente provista por otro paquete si éste está instalado. En esta sección también van paquetes que son necesarios únicamente durante el desarrollo.\nAsí se verán en el archivo DESCRIPTION:\nImports:\n    dplyr,\n    tidyr\nSuggests:\n    ggplot2,\n    testthat\nEn este caso, el paquete utiliza funciones de dplyr y tidyr en su funcionalidad básica. El paquete ggplot2 puede estar en Suggests porque la funcionalidad de graficado usa ggplot2 sólo si éste está instalado y usa plot base si no. El paquete testthat es el que vamos a usar durante el desarrollo para realizar los tests, pero no es necesario para usar el paquete.\nY por supuesto, podemos usar usethis para agregar nuevas dependencias con usethis::use_package(\"dplyr\"). La función nos devuelve:\n#&gt; ✔ Adding dplyr to 'Imports' field in DESCRIPTION.\n#&gt; ☐ Refer to functions with `dplyr::fun()`.\nHabrás notado que nos pide que llamemos a las funciones usando esta notación dplyr::fun(). Esto es muy importante, en el código de funciones nunca debemos incluir la carga de librerías con library(). Hay dos razones por las que no hacemos esto:\n\nEn el contexto de un paquete queremos ser eficientes y trabajar de manera ordenada. Si llamaramos a una librería entera con library() estaríamos cargando todas las funciones importadas por ese paquete cuando tal vez solo necesitamos una. Esto no es eficiente y puede traer problemas si otros paquetes tienen funciones con el mismo nombre.\nLa sintaxis dplyr::fun() ayuda a entender de donde viene la función y diferenciar, por ejemplo stats::filter() de dplyr::filter() que tienen argumentos y funcionalidades completamente distintas.\n\nEs fácil olvidarse de las dependencias, lo bueno es que esta es una de las cosas que se chequean cuando corremos los chequeos R CMD.\n\nR Base proporciona varias herramientas para chequear un paqeute. R CMD check es el método oficial para comprobar que un paquete de R es válido. Es esencial pasarlos checks de R CMD check si planeas enviar tu paquete a un repositorio oficial. Pero aún si ese no es el plan es muy recomendable correr estos checks periodicamente. R CMD check detecta muchos problemas comunes que de otro modo descubrirías por las malas.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#tests",
    "href": "11_errores.html#tests",
    "title": "\n12  Dependencias y tests\n",
    "section": "\n12.3 Tests",
    "text": "12.3 Tests\nLas pruebas o tests son una parte vital del desarrollo de paquetes: garantizan que tu código haga lo que vos necesites que haga.\nHasta ahora, tu flujo de trabajo tiene más o menos esta pinta:\n\nEscribis una función.\nLa cargas con devtools::load_all(), quizás mediante Ctrl/Cmd + Shift + L.\nLa corrés en la consola para ver si funciona.\nRevisas y modificas lo necesario.\n\nSi bien estás chequeando el código al hacer todo esto, sólo lo estás haciendo de manera informal. El problema con este enfoque es que cuando vuelvas a este código dentro de 3 meses para añadir una nueva funcionalidad, es probable que hayas olvidado parte de lo que hace. Esto hace que sea muy fácil romper el código que solía funcionar.\nEn esta sección vamos a ver como crear test para las funciones usando el paquete testhat. Además, incluiremos estos tests en el paquete para y crearemos un flujo de trabajo que nos permita chequear las funciones del paquete cada vez que hagamos un cambio.\n\n12.3.1 Configuración inicial\nPara configurar tu paquete para usar testthat, ejecutá en la consola:\nusethis::use_testthat(3)\nEsto hará:\n\nCreará un directorio tests/testthat/.\nAñadir testthat a la lista de Suggests en DESCRIPTION y especificará la versión de testthat 3e en Config/testthat/edition:\n\nSuggests: testthat (&gt;= 3.0.0)\nConfig/testthat/edition: 3\n\nCrea un archivo tests/testthat.R que ejecuta todas las pruebas cuando se ejecute R CMD check.\n\n12.3.2 Creando tests\nEs esperable que cada función tenga al menos 1 test, probablemente más de uno si la función es compleja. Normalmente por cada archivo .R que contiene 1 función o una familia de funciones tendremos un archivo .R con los tests correspondientes que se guardará en tests/testthat/. Por ejemplo para la función suma() que está en R/suma.R tendrá tests en tests/testthat/test-suma.R.\nPor supuesto usethis tiene una función que crea estos archivo en el lugar que corresponde:\n\nuse_test(\"suma\")  # Crea y abre tests/testthat/test-suma.R\n\nAdemás, si el archivo ya existe siemplemente lo abre para agregar o editar el test.\nAhora si, un test está formado por 1 o más expectativas, es decir lo que esperamos que devuelva la función ya sea el resultado o un error si recibe el argumento equivocado. Por ejemplo, para la función suma() la expectativa es que si le pasamos los argumentos 2 y 2, devuelva 4. En este caso el test tendrá esta pinta:\n\ntest_that(\"la suma funciona\", {\n  expect_equal(object = suma(2, 2), expected = 4)\n})\n\n\ntest_that() es la función principal que encapsula las expectativas e incluye una descripción de lo que hace el test, en este caso “la suma funciona”.\nexpect_equal() es una de las posibles expectativas o funciones que revisan que la funciona devuelva lo que esperamos en cada caso. Como esta función hay otras que nos van a permitir revisar el resultado de distintas funciones. Todas reciben al menos 2 argumentos, la expresión que queremos testear y el resultado/mensaje/valor esperado.\n\nEn todos los casos si el resultado que devuelve la expresión y lo esperado no coinciden, test_that() devolverá un error.\nEn este punto ya podemos correr este test o las expectativas de manera individual. Para esto primero hay que correr devtools::load_all() o usar el atajo de teclado para cargar la versión actual del paquete y luego ejecutar cada expectativa o el test completo. Al correr el test entero, si se cumple la expectativa veremos esto en la consola:\nTest passed\n\n12.3.3 Expectativas\nHablemos de las expectativas. A simple vista esta linea de código expect_equal(object = suma(2, 2), expected = 4) parece casi ridícula, por supuesto que la función que acabamos de escribir va a devolver 4 cuando le pasemos como argumentos 2 y 2. Además, seguro corriste la función varias veces con distintos argumentos para asegurarte que de lo que esperamos.\nSin embargo es posible que en el futuro, cambiemos algo en la función ´suma()´ por alguna razón y que deje de dar el resultado correcto. Para esto estan los tests, para detectar errores en el futuro.\nDe la misma manera que usamos expect_equal() para evaluar que el resultado de la función sea igual a lo que esperamos, hay otras funciones que revisan diferentes elementos:\n\nexpect_length() revisa si la función devuelve un vector de un largo específico.\nexpect_lt(), expect_lte(), expect_gt(), expect_gte() chequean si el valor numérico que devuelve la función cumple la condición mayor/menor correspondiente.\nexpect_true(), expect_false() chequean si el resultado es TRUE o FALSE.\nexpect_error(), expect_warning(), expect_message(), expect_condition() revisa si la función devuelve un error, warning, mensaje o condición.\n\nVeamos en más detalle este último grupo. Normalmente, cuando se testea un error, nos preocupan dos cosas:\n\n¿El código falla? Específicamente, ¿falla por la razón correcta?\n¿El mensaje de error tiene sentido para la persona que tiene que resolver el error?\n\nUn posible ejemplo de uso para expect_error() sería:\n\ntest_that(\"no suma caracteres\",\n  expect_error(suma(\"1\", 1), \"Los argumentos deben ser numéricos\")\n)\n\nSabemos que si intentamos sumar \"1\" y 1 la función devolverá el mensaje “Los argumentos deben ser numéricos”. Pero en un futuro podría pasar que sin querer modificamos esta parte del código y deja de dar ese mensaje. El test podrá identificar ese cambio y avisarnos.\n\nAhora vamos a trabajar con la primera función que vimos: pulgadas_a_centimetros().\n\nSi la función no es parte de paqueteprueba, agregala. Podés copiar el código que está en la sección Funciones.\nHace una lista de expectativas, es decir, posibles resultados o mensajes que podría devolver la función en distintas situaciones.\nIdentifica que función de la familia expect_xxX() deberías usar en casa caso.\nEscribí al menos 2 tests usando las expectativas que definistes.\nEjecutá cada expectativa de manera individual para asegurarte que funcionan.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#testeo-general",
    "href": "11_errores.html#testeo-general",
    "title": "\n12  Dependencias y tests\n",
    "section": "\n12.4 Testeo general",
    "text": "12.4 Testeo general\nHasta ahora ejecutamos cada test uno por uno a mano. Esto tiene sentido cuando estamos trabajando en cada uno. Sin embargo al final del día o luego de resolver un problema o agregar algo nuevo al paquete es importante correr todos los test juntos. Podemos hacer esto con devtools::test() o el atajo de teclado Ctrl+Shif+T. En el caso de nuestro paquete de prueba y si sale todo bien, nos devolverá algo como esto:\nℹ Testing paqueteprueba\n✔ | F W  S  OK | Context\n✔ |          1 | pulgadas_a_centimetros                                                             \n✔ |          2 | suma                                                                                 \n\n══ Results ═══════════════════════════════════════════════════════════════════════════════════════════\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\nEl flujo de trabajo ahora tiene la siguiente pinta:\n\nPero también es muy común correr directamente devtools::check() o el atajo Ctrl/Cmd + Shift + E. Este comando corre algo llamado “R CMD checks”. Es un conjunto de más de 50 test que cualquier paquete debe pasar para cumplir con los estandares definidos. Entre otras cosas chequea:\n\nMetadatos\nLa estructura del paquete y los archivos que contiene\nDESCRIPTION: información, dependencias, etc.\nNAMESPACE\nCódigo de R: revisa errores de sintaxis, caracteres no ASCII y otros problemas asociados a las funciones\nDatos del paquete (si hubiera)\nDocumentación: metadatos, links, ejemplos, etc.\nTests\nViñetas\n\nPor el estado en el que está nuestro paqueteprueba, seguramente al correr R CMD checks nos vamos a encontrar con problemas. Esto es normal, es el momento de resolverlos antes de continuar.\nLa salida de los checks es bastante larga porque revisa varias cosas, pero esta es la parte que nos interesa:\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n❯ checking code files for non-ASCII characters ... WARNING\n  Found the following files with non-ASCII characters:\n    R/pulgadas_a_centimetros.R\n    R/suma.R\n  Portable packages must use only ASCII characters in their R code and\n  NAMESPACE directives, except perhaps in comments.\n  Use \\uxxxx escapes for other characters.\n  Function 'tools::showNonASCIIfile' can help in finding non-ASCII\n  characters in files.\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' import not declared from: 'cli'\n\n0 errors ✔ | 3 warnings ✖ | 0 notes ✔\nError: R CMD check found WARNINGs\nExecution halted\n\nExited with status 1.\nEn este caso no encontró errores pero si 3 warnings, hay que resolverlos.\nEl primero ocurre en el archivo DESCRIPTION, nos dice que no encontró una licencia estandar. Vamos a hablar un poco más de licencias en otra sección pero en escencia una licencia establece que permisos le damos a otras personas sobre el paquete. Vamos a establecer una de las que sugiere el mensaje usando usethis:\n\nusethis::use_mit_license()\n\nEsta función agrega los archivos necesarios con el texto de la licencia (en inglés). Y primer warning, ¡resuelto!\nEl segundo warning nos dice que encontró caracteres no ASCII en los archivos que lista. Estos caracteres son seguramente son las tildes o alguna ñ que usamos en el código de las funciones (normalmente en los mensajes de error). No podemos evitar usarlos porque hablamos en español, pero tendremos que reemplazarlos por su versión unicode para que el paquete funcione correctamente (particularmente en Windows!).\nEsto implica que tendremos que volver a cada uno de esos archivos, buscar los caracteres no ASCII y reemplazarlo por su código unicode. Podemos googlearlo o usar stringi::stri_escape_unicode(). En este caso el problema está en los mensajes de error: “Los argumentos deben ser numéricos.” y en particular la “é”. Googleando resulta que en unicode se escribe \\U00E9, por lo tanto el texto queda:\n\"Los argumentos deben ser num\\U00E9ricos.\"\nSi bien no es legible, cuando la función devuelva este mensaje se verá de manera correcta. Otro warming resuelto!\nFinalmente, la tercera advertencia nos dice que estamos usando el paquete cli pero que no está en la lista de dependencias. Podemos agregarlo usando usethis como vimos al comienzo:\n\nusethis::use_package(\"cli\")\n\nY con eso resolvemos el último problema! Al correr de nuevo R CMD checks, veremos lo siguiente:\n── R CMD check results ───────────────────────────────────────────────── paqueteprueba 0.0.0.9000 ────\nDuration: 21.8s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nR CMD check succeeded",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#integración-continua",
    "href": "11_errores.html#integración-continua",
    "title": "\n12  Dependencias y tests\n",
    "section": "\n12.5 Integración continua",
    "text": "12.5 Integración continua\nLa integración continua (CI, por las siglas en inglés) ejecuta tests sobre el software automáticamente. En la práctica significa que un conjunto de test se ejecutará automáticamente a través de GitHub Actions cada vez que hagas un commit o pull request a GitHub.\nLa CI automatiza la ejecución de tests globales de los paquetes, como R CMD check. Hacerlo utilizando GitHub Actions permite además correr los tests en distintos sistemas operativos y así asegurarte que tu paquete funciona correctamente en Windows, Linux y OS. Podemos usar usethis para generar la receta o workflow que correrá GitHub cada vez que hagamos un push al paquete con:\n\nusethis::use_github_action(\"check-standard\")\n\nEste flujo de trabajo ejecuta R CMD check a través del paquete rcmdcheck en los tres principales sistemas operativos (Linux, macOS y Windows) en la última versión de R y en R-devel.\nSi bien GitHub manda mails avisando cuando alguno de estos chequeos falla, cuando hacemos cambios imporantes tenemos que prestar particularmente atención y asegurarnos que todo está en orden.\nOtra de las cosas que podemos hacer con CI es revisar la cobertura de los tests a través de un servicio de testing como Codecov o Coveralls. Recomendamos utilizar Codecov. Para activar Codecov para el paquete usaremos:\n\nusethis::use_github_action(\"test-coverage\")\n\nLa función crea un archivo .github/workflows/test-coverage.yaml. También será necesario darle acceso a Codecov al repositorio de GitHub donde está el paquete, para esto lo mejor es seguir la guía de inicio rápido de Codecov (en inglés) para saber cómo hacerlo.\nTambién podemos revisar la covertura de tests de manera local con devtools::test_coverage() que nos devuelve un resumen interesante de los tests:\n\nEsto nos dice que el 56.25% del código en el paquete está cubierto por tests y el porcentaje para cada archivo/función individual. Si bien llegar al 100% no es del todo práctico o realista, se espera que el paquete tenga un porcentaje alto de covertura de tests cercano al 90%.\nMás interesante aún es lo que nos muestra para cada archivo. En este caso vemos que lineas dentro de suma.R son revisadas o cubiertas por los tests:\n\nLas lineas sombreadas con verde nos indican que los tests pasaron por ahí y ejecutaron ese código. Si las lineas están sombreadas con rojo, no las estamos cubriendo con ninguno de nuestros tests. Con esto descubrimos que no estamos testeando posibles problemas asociados a incluir números negativos y podríamos ahora sumar un nuevo test.\n\nEs posible que el porcentaje de covertura de Codecov y de devtools::test_coverage() sea algo distinto. Esto es porque hacen cosas ligeramente distintas. No es necesario preocuparse!\n\n\nEs momento de revisar el estado del paqueteprueba\n\nCorré R CMD checks.\n\n\nSi encontrás errores o warnings intentá resolverlos.\n\n\nAgregá una GitHub Action para que GitHub corrá R CMD checks cada vez que hagas push.\n\n\nHace push al repositorio remoto y chequeá el resultado de los checks\n\n\nAgregá una GitHub Action para revisar la covertura de los tests\n\n\nRevisá que partes del código estás testeando y que te falta.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "11_errores.html#ex-tests",
    "href": "11_errores.html#ex-tests",
    "title": "\n12  Dependencias y tests\n",
    "section": "\n12.6 Construyendo un paquete de R paso a paso",
    "text": "12.6 Construyendo un paquete de R paso a paso\n\nEl paquete de datos meteorológicos también va a necesitar tests. Es el momento de agregarlos.\nTests para las funciones\n\nRevisá las funciones que incluiste en tu paquete y:\n\n\nFalta definir alguna dependencia (seguramente dplyr!)\nPensá al menos 2 expectativas que deberían cumplir cada una de las funciones\nCrea tests para las funciones\n\nR CMD Checks\n\nCorré R CMD checks y resolvé los posibles errores y warnings.\nActivá una GitHub Action para correr R CMD checks con cada push\n\nCovertura de checks\n\nActivá una GitHub Action para chequear automáticamente la covertura de tests\nRevisá la covertura de tests localmente, ¿qué partes del código no son testeadas?\n\nEl paquete debe tener al menos un 75% de covertura de tests.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Dependencias y tests</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html",
    "href": "12_contribuir.html",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "",
    "text": "13.1 Objetivos de aprendizaje",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#objetivos-de-aprendizaje",
    "href": "12_contribuir.html#objetivos-de-aprendizaje",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "",
    "text": "Editar un archivo README y NEWS de un proyecto para que de la bienvenida a las personas que quieran usar el paquete o colaborar.\nComprender la importancia de tener un Código de Conducta explícito y cómo crear uno relevante para un proyecto.\nComprender el propósito de las licencias, cómo elegir una licencia y crear un archivo LICENSE.\nComprender la importancia de incluir una guia para contribuir con el proyecto.\nCrear y gestionar GitHub Issues y sus etiquetas para hacer un seguimiento de los errores y y mejoras del proyecto.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#crear-una-comunidad-amigable",
    "href": "12_contribuir.html#crear-una-comunidad-amigable",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "13.2 Crear una comunidad amigable",
    "text": "13.2 Crear una comunidad amigable\nAhora que el paquete está tomando forma e incluso tienes un sitio web para compartir información sobre él, hay cosas algunas cosas que podemos sumar para ayudar a otras personas a entender cómo colaborar o usar el paquete. Esta sección también te ayudará a identificar estos mismos elementos en otros proyectos en los que quieras contribuir.\n\n13.2.1 Crear un README amigable\nEl README es la puerta de entrada a tu paquete, es importante que sea amigable para cualquier persona que quiera usarlo o colaborar, independientemente de su nivel de experiencia.\nHasta ahora el README debería tener:una descripción del paquete, instrucciones para instalar y usar el el paquete y algunos ejemplos. Revisemos el contenido desde la perspectiva de una persona que recién se encuentra con el paquete:\n\n¿Es amigable?\n¿Es fácil de entender?\n¿Contiene toda la información necesaria para utilizar o contribuir con el paquete?\n\nEs posible que no podamos responder que si a todo lo anterior, para mejorar nuestro README podemos agregar o mejorar los siguientes aspectos:\n\nUna buena manera de empezar un README es dando la bienvenida. Podés además presentarte y a todo el equipo.\nEscribe la descripción de tu proyecto de forma que sea comprensible para un amplio abanico de personas. Evita utilizar jerga y asegurate de definir todos los términos o conceptos que sean específicos del sector.\n¿De qué trata este proyecto?\n¿A quién va dirigido?\n¿Por qué existe este proyecto?\n¿Qué hace que tu proyecto sea único o distinto que otros?\nDescribí cómo se utiliza el paquete con ejemplos sencillos.\nDescribí qué tipo de ayuda o contribuciones estás buscando.\n\nAun si no esperas que tu paquete sea usado por otras personas o que las personas esten interesadas en colaborar, escribir un READM claro también es extremadamente útil para tu yo del futuro. El mero hecho de pensar en la documentación de tu paquete es una forma perfecta re revisar y aclarar las ideas y con suerte prevenir errores y problemas.\n\nEtiquetas del README\nSi alguna vez revisaste el README de cualquier paquete de habrás notado que tiene etiquetas o badges al inicio. Sirven para mostrar distintas características del paquete, si pasa los checks, cual es la cobertura de test, etc. Agreguemos la primera con:\nuse_lifecycle_badge(\"experimental\")\n\n¿Que cambios pueden observar en el README?\nKniteen el archivo.\nHagan commit y push al repositorio remoto y revisen como se ve el README en GitHub\n\n¿Qué otras etiquetas existen?\n\n\n\n13.2.2 Guía de contribución\nEs muy común encontrar el siguiente párrafo al final de cualquier README de un paquete de R:\n\nCómo contribuir Para contribuir con este paquete podés leer la siguiente guía para contribuir.\n\nY normalmente incluye un link a un archivo con detalles más específicos sobre como contribuir: el archivo CONTRIBUTING.md. Estas guías de contribución ayudan a las personas a interactuar con tu proyecto y te ayudarán a planificar los tipos de contribuciones que estás buscando.\nLa función usethis::use_tidy_contributing() crea automáticamente el archivo CONTRIBUTING.md en la carpeta .github con algunas guias de contribución en el estilo Tidyverse.\nPor supuesto, esta guia estará en inglés pero podemos traducirla al español si el resto de la documentación del paquete también está en español. A modo de ejemplo, esta es una guía de contribución en español.\nEs posible además, dependiendo de tu paquete, que necesites agregar secciones extras para explicar como informar sobre errores en el paquete o como ponerse en contacto con el equipo que desarrolla el paquete.\n\n\nAgregá el archivo CONTRIBUTING usando usethis. Podés hacer una traducción automática del contenido usando DeepL.\nAgregá indicaciones en el README para encontrar el archivo CONTRIBUTING, debería ser un link.\n\n\n\n\n13.2.3 Código de conducta\nPara crear una comunidad inclusiva y segura, una herramienta muy importante es el Código de conducta. El Código de Conducta ayuda a establecer claramente qué comportamientos son aceptables y cuáles no lo son Esto ayuda ayuda a evitar problemas y define cómo se tratarán los problemas en caso de que se produzcan.\nLa función usethis::use_code_of_conduct() crea un archivo llamado CODE_OF_CONDUCT.md que contiene el texto de Contributor Covenant. Nuevamente estará en inglés, pero acá hay un ejemplo en español.\nRedactar un código de conducta desde cero es una tarea compleja, por eso recomendamos revisar los códigos de conducta de otros proyectos y organizaciones.\nLos archivos CONTRIBUTING.md y CODE_OF_CONDUCT.md son tratados por GitHub de forma especial, por ejemplo aparecen en el menú de la izquierda cuando visitamos el repositorio.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#licencia",
    "href": "12_contribuir.html#licencia",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "13.3 Licencia",
    "text": "13.3 Licencia\nMientras que un código de conducta describe cómo deben interactuar las personas que participan del proyecto entre sí, una licencia dicta cómo pueden utilizarse y redistribuirse los materiales del proyecto. Si la licencia o un acuerdo de publicación dificultan las contribuciones, es menos probable que el proyecto atraiga a nuevas personas, por lo que la elección de la licencia es crucial para la sostenibilidad del proyecto a largo plazo.\nLa clase pasada agregamos la licencia MIT en nuestro paquete. Para evitar líos legales, todo proyecto debe incluir una licencia explícita. Esta licencia debe elegirse con tiempo, ya que cambiar una licencia puede ser complicado. En general tambien tendremos una licencia que aplica al software y otra que aplica a los datos y documentos.\n\n13.3.1 Software\nPara elegir la licencia adecuada para nuestro software, debemos entender la diferencia entre dos tipos de licencia. La Licencia MIT (y su hermana cercana la Licencia BSD) dicen que la gente puede hacer lo que quiera con el software siempre que cite la fuente original, y que los autores no aceptan ninguna responsabilidad si las cosas no funcionan. La Licencia Pública GNU (GPL) otorga a los usuarios derechos similares, pero les obliga a compartir su propio trabajo en las mismas condiciones.\n\n\n13.3.2 Datos y documentos\nCuando se trata de datos y documentos, la familia de licencias más utilizada es la de Creative Commons. Han sido redactadas y verificadas por juristas y son bien conocidas por la comunidad.\nLa opción más liberal se denomina CC-0, donde el «0» significa «cero restricciones». Esto pone el trabajo en el dominio público, es decir, permite que cualquiera que quiera utilizarla lo haga, como quiera, sin restricciones. Suele ser la mejor opción para los datos, ya que simplifica el análisis agregado de conjuntos de datos de distintas fuentes.\nLas otras licencias agregan restricciones:\n\nAtribucion - BY: permite hacer lo que se quiera con la obra siempre que se cite la fuente original. Esta es la mejor licencia para documentos: queremos que la gente los comparta ampliamente, pero también queremos que se reconozca nuestro trabajo.\nSin derivados - ND: impide que se creen versiones modificadas de nuestro trabajo.\nCompartir igual - SA: exige que las obras que incorporen las nuestro trabajo se compartan en los mismos términos que lo hicimos nosotros.\nSin uso comercial - NC: no significa que la gente no pueda cobrar dinero por algo que incluya nuestro trabajo. Esta cláusula significa que la gente no puede cobrar por algo que utilice nuestro trabajo sin nuestro permiso explícito, que podemos dar en los términos que queramos.\n\n\nLa familia de funciones usethis::use_NOMBRE_license(), reemplazando NOMBRE con una licencia de la lista, crea el archivo LICENSE.md con el texto de esa licencia.\nPor ejemplo, use_ccby_license() agrega la licencia Creative Commons con atribucion al proyecto.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#usando-github-issues-para-mantener-tu-proyecto",
    "href": "12_contribuir.html#usando-github-issues-para-mantener-tu-proyecto",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "13.4 Usando GitHub Issues para mantener tu proyecto",
    "text": "13.4 Usando GitHub Issues para mantener tu proyecto\nTu paquete ahora vive en un repositorio de GitHub, y has creado varios archivos útiles que orientarán a los usuarios y colaboradores de tu proyecto. Ahora bien, ¿cómo sabe alguien que quiere contribuir lo que debería estar haciendo?\nTanto si trabajamos solos como con un grupo de personas, la mejor forma de gestionarlo es utilizar un sistema de seguimiento de issues para controlar las tareas que tenemos que completar o los problemas que tenemos que solucionar. Los issues a veces se denominan tickets, por lo que los sistemas para su seguimiento también reciben el nombre de sistemas de tickets. También se les suele llamar sistemas de gestion de errores, pero pueden utilizarse para gestionar diferentes tipos de trabajo.\nGitHub permite crear issues para un proyecto, comentarlos y buscar en todos los issues disponibles.\n\nHemos creado issues en sus repositorios durante la cursada. Se puede generar una conversacion en los issues hasta que se llega a un concenso y luego se pueden cerrar.\nA pesar que esten cerrados los issues igualmente quedan en el historial de GitHub.\n\nEn términos generales, las personas crean tres tipos de issues:\n\nPara informar sobre errores y describir los problemas que han encontrado.\nPedidos de características o funcionalidades nuevas, como «añadir esta función a este paquete» o “añadir un menú al sitio web”.\nPreguntas sobre el uso del paquete, el funcionamiento de partes del proyecto o su orientación futura.\n\nCuanto más grande o antiguo es un proyecto, más difícil es encontrar cosas, a menos que trabajemos para hacer que las cosas sean fáciles de encontrar. GitHub permite añadir etiquetas a los issues para facilitar su búsqueda y organización.\nEn GitHub hay etiquetas definidas por defecto pero también se puede definir nuevas etiquetas según la necesidad. Algunas de las etiquetas más usadas son bug (o error), feature (o nueva funcionalidad), question (o pregunta), good first issue (o para principiantes), urgent (o urgente), duplicate (duplicado), entre otros.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#la-comunidad-de-r",
    "href": "12_contribuir.html#la-comunidad-de-r",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "13.5 La comunidad de R",
    "text": "13.5 La comunidad de R\n\nUna comunidad de práctica es un grupo de personas que comparten una pasión por algo que saben hacer, y que interactúan regularmente para aprender a hacerlo mejor – Etienne Wenger\n\nHasta el momento vimos diferentes maneras de hacer que tu paquete este listo para que otras personas colaboren.\nAhora vamos a ver una serie de grupos y organizaciones en las cuales podes involucrarte para aprender, mejorar tus capacidades relacionadas a la ciencia de datos, incrementar tu red de contactos y compartir tu trabajo.\nLo que se conoce globalmente como la comunidad R o R Community esta formada por un conjunto de organizaciones sin fines de lucro, companias privadas, universidades y fundaciones, todas trabajando con el lenguage R para diferentes disciplinas y objetivos.\nLa Fundacion R y el Consorcio R son dos de las organizaciones que planifican y financian iniciativas que hacen al lenguaje R avanzar.\n\n13.5.1 Grupos de Usuarios de R\nEl Consorcio de R (RConsortium) tiene un programa que patrocina grupos de usuarios (RUG) pero que son y que hacen?\nLos RUG son personas que usan R que se reúnen periódicamente en el lugar donde viven para compartir experiencias y conocimientos.\nFomentan el aprendizaje colectivo, el trabajo en comunidad y el crecimiento grupal, en el contexto de la utilización de R en actividades profesionales y/o académicas (o recreativas!).\nEn los encuentros se comparten talleres sobre distintos paquetes o herramientas relacionadas con R, novedades sobre eventos relacionados, discusiones sobre tópicos de ciencia de datos, o disciplinas especificas como R en el agro o R en educacion.\nToda persona interesada en R es bienvenida, independientemente de su grado de familiaridad con el lenguaje.\n\nExisten varios RUGs en America Latina y en Argentina. Por ejemplo existe RenRosario y RenBuenosAires. Muchos de los grupos tienen eventos en linea a los cuales pueden sumarse.\n\nUn grupo especial de RUGs es R-Ladies que se centra en reducir la brecha de genero en la comunidad R por medio de mentorias y eventos abiertos y gratuitos en sus capitulos alrededor del mundo. R-Ladies tiene 10 capitulos en Argentina y mas de 240 alrededor del mundo. En total hay mas de 100000 personas que participan de estos grupos.\n\n\n13.5.2 Conferencias\nEsta comunidad tiene una serie de conferencias donde nos encontramos todos los años. Para America Latina la mas importante es LatinR. Luego useR! y Posit::Conf son las otras dos conferencias donde es muy interesante poder participar.\n\n\n13.5.3 Ciencia abierta, reproducbilidad y software\nExisten otras comunidades relacionadas a R con distintos objetivos. Por ejemplo rOpenSci que se enfoca en ayudar a crear paquetes de R para hacer ciencia creando una comunidad de personas que desarrollan, revisan y mantienen esos paquetes.\nOtra comunidad es The Carpentries que busca enseñar herramientas y habilidades para hacer ciencia de manera abierta y reproducible.\nEsta lista no está completa, existen muchas comunidades e iniciativas y aparecen nuevas muy seguido!",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "12_contribuir.html#ex-contribuir",
    "href": "12_contribuir.html#ex-contribuir",
    "title": "13  Contribuir y aceptar contribuciones",
    "section": "13.6 Construyendo un paquete de R paso a paso",
    "text": "13.6 Construyendo un paquete de R paso a paso\n\nCon esta sección terminamos de revisar los elementos principales de un paquete de R que pone el foco no solo en el desarrollo del código, también en generar un proyecto que sea sostenible y recibe contribuciones.\nEs hora de agregar los últimos toques al paquete meteorológico:\n\nRevisá el README para que no falte nada, incluyendo etiquetas, los autores y como contribuir.\nAgregá los archivos CONTRIBUTING y el código de conducta.\nRevisá que el paquete tenga la licencia que corresponde.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Contribuir y aceptar contribuciones</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html",
    "href": "A_instalacion.html",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "",
    "text": "Instalando R\nEste anexo detalla los pasos a seguir para instalar todo el software que vamos a necesitar para las clases:\nTambien vamos a ver como crear cuentas en las plataformas que vamos a utilizar:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-r",
    "href": "A_instalacion.html#instalando-r",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "",
    "text": "Ubuntu o derivados\nPara tener la última versión, tenés que agregar los repositorios de CRAN. Para hacerlo, vas a tener que tener permisos de administrador. Los detalles están en esta página, pero el resumen es:\nsudo apt update -qq\nsudo apt install --no-install-recommends software-properties-common dirmngr\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\"\nsudo sudo apt install r-base r-base-dev\nLas instrucciones incluyen la isntalación de r-base-dev que necesitarás para desarrollar paquetes.\nSi todo salió bien, tenés que tener instalado R en tu máquina y podés ejecutarlo con el comando R en la consola.\n\n\n\nMac\n\nIr a CRAN: https://cran.r-project.org\nHacer click en el link “Download R for (Mac) OS X”.\nDescarga el paquete correspondiente a tu sistema operativo.\nEjecuta el paquete.\n\n\nEntorno de desarrollo de paquetes para Mac\nPara desarrollar paquetes de R con Mac tendrás que instalar la herramienta Xcode que además, requiere que te registres como desarrollador/a de Apple. Esto es gratuito para personas que solo necesitan instalar aplicaciones. Una vez que te registraste deberás correr la siguiente línea de código en la terminal:\nxcode-select --install\nO installar xcode desde el Mac App Store.\n\n\n\nWindows\n\nEntrá a https://cran.r-project.org/bin/windows/base/ y bajate el instalador haciendo click en el link grandote que dice “Download R x.x.x for Windows”.\nUna vez que se bajó, hacé doble click en el archivo y seguí las instrucciones del instalador.\nUna vez que se termine de instalar, te va a aparecer un ícono como este en el escritorio o en los programas instalados: \nAl ejecutarlo, les tiene que aparecer algo como esto:\n\n\nSi ves una ventana así significa que ya tenés instalado R, pero seguí leyendo! Todavía falta unos pasos para poder sacarle todo el jugo: necesitamos instalar RTools.\n\nInstalando RTools\nPara instalar algunos paquetes de R en Windows, y en particular para desarrollar un nuevo paquete, vas a necesitar instalar un programa adicional llamado rtools.\n\nEntrá a https://cran.r-project.org/bin/windows/Rtools/ y descargate el instalador de version mas nueva, en este momento es Rtools45. Para eso hacer click en Rtools45 y en es nueva pagina hacer click en Rtools45 installer. Aquí estamos asumiendo que tu version de R también es 4.5.x\nEjecuta el instalador y segui las instrucciones.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-rstudio",
    "href": "A_instalacion.html#instalando-rstudio",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Instalando RStudio",
    "text": "Instalando RStudio\nIngresa en el sitio web de Posit y descarga RStudio para desktop para tu sistema operativo: https://posit.co/download/rstudio-desktop/\n\nUbuntu o derivados\nSi tenés instalada una interfaz gráfica para instalar archivos .deb, ejecutando el archivo que descargaste ya vas a poder instalar RStudio. Si no, abrí una terminal en el directorio donde bajaste el archivo y ejecutá\nsudo dpkg -i ARCHIVO\nReemplazando ARCHIVO por el nombre del archivo instalador.\nEs posible que salte algún error por falta de alguna dependencia, en ese caso usá\nsudo apt-get -f install\nY debería estar arreglado.\nTerminada la instalacion, al ejecutar RStudio les tiene que aparecer una ventana como esta:\n\n\n\nMac\nSi no lo hiciste previamente, la primera vez que abras RStudio te ofrecerá instalar las herramientas de XCode para línea de comando. Aceptá haciendo click en instalar.\n\n\nWindows\nComo siempre, doble click en el archivo y seguir los pasos de instalación.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#instalando-git",
    "href": "A_instalacion.html#instalando-git",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Instalando Git",
    "text": "Instalando Git\nGit es una herramienta para control de versiones, vamos a utilizarla para trabajar colaborativamente.\nEn la pagina de Git podrás descargar el instalador para tu sistema operativo.\nEn esa misma pagina hay una guia de instalacion para cada sistema operativo en castellano.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#crear-cuentas",
    "href": "A_instalacion.html#crear-cuentas",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Crear cuentas",
    "text": "Crear cuentas\n\nCrear una cuenta en GitHub\nGitHub es una de las interfaces y repositorios mundiales mas conocidos y utilizados por quienes desarrollan software. Vamos a utilizarlo para compartir el codigo que vamos a escribir en la materia.\n\nIr a https://github.com/.\nHacer clik en Registrarse or Sign up.\nSeguir las indicaciones para crear la cuenta personal.\nUno de los pasos implica chequear que son una persona y luego validar la direccion de email que usaste para crear la cuenta.\n\n\n\nCrear una cuenta en Posit Cloud\n\nIr a https://posit.cloud/plans/free.\nHacer clik en “Sign Up” y seguir las indicaciones para crear la cuenta personal.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "A_instalacion.html#configuración-de-git-y-github",
    "href": "A_instalacion.html#configuración-de-git-y-github",
    "title": "Appendix A — Preparando el entorno de trabajo",
    "section": "Configuración de Git y GitHub",
    "text": "Configuración de Git y GitHub\nAhora que ya tenés git instalado y una cuenta en GitHub, es importante completar la configuración necesaria para que puedas trabajar. Hay varias maneras de hacerlo, en este caso lo haremos desde R usando el paquete usethis.\n\nAbrí RStudio e instalá usethis corriendo el siguiente código en la consola:\n\ninstall.packages(\"usethis\")\n\nConfigurá tu nombre y correo electrónico:\n\nusethis::use_git_config(user.name = \"Juan Perez\",\n               user.email = \"juan@ejemplo.org\")\nSustituyéndolo por tu nombre y el correo electrónico asociado a tu cuenta de GitHub. git usará esta información para registrar quien hizo cambios en un archivo. Veremos esto en más detalle durante la materia.\n\nConfigurá tu PAT\n\nEl PAT o “personal access token”, mejor conocido como token es una especie de contraseña que deberás setear en tu computadora para poder hacer cambios en GitHub.\nPrimero tendrás que crear el token:\nusethis::create_github_token()\nSe abrirá la ventana de GitHub y ahí tendrás que seguir los pasos para crear el token y copiarlo (muy importante!). Por las dudas no cierres esta ventana.\nAhora corré el siguiente código para setear el token en tu computadora:\ngitcreds::gitcreds_set()\nElegí crear/guardar el token. Si tenés Ubuntu esto no termina acá, tendrás que seguir los pasos en esta guia para guardar el token de manera permanente.\n\nVacuná tu instalación de git:\n\nusethis::git_vaccinate() \nEsta función agrega algunos archivos y configuraciones que se consideran buenas prácticas. Podés leer la documentación de la función para más detalles.\n\nChequeá que todo esté en orden:\n\nusethis::git_sitrep() \nEsta función devuelve el estado de situación de tu configuración de git y GitHub. Revisá que aparezca tu nombre y mail, que aparezca Vaccinated: TRUE y que Personal access token for \"https://github.com\": &lt;discovered&gt; esté tal cual.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Preparando el entorno de trabajo</span>"
    ]
  },
  {
    "objectID": "B_config_pk.html",
    "href": "B_config_pk.html",
    "title": "Appendix B — Configuración para desarrollar paquetes",
    "section": "",
    "text": "B.1 Prepara tu sistema\nPara empezar, asegurate de que tenés la última versión de R (al menos 4.5.0 que es la versión que se utiliza para generar estos materiales), y luego ejecuta el siguiente código para obtener los paquetes que necesitarás:\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\", \"usethis\"))",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Configuración para desarrollar paquetes</span>"
    ]
  },
  {
    "objectID": "B_config_pk.html#setup-tools",
    "href": "B_config_pk.html#setup-tools",
    "title": "Appendix B — Configuración para desarrollar paquetes",
    "section": "\nB.2 Herramientas para construir R",
    "text": "B.2 Herramientas para construir R\nPara ser plenamente capaz de construir paquetes de R a partir del código fuente, también necesitarás un compilador y algunas otras herramientas. Esto puede no ser estrictamente necesario hasta que quieras construir paquetes que contengan código C o C++. Especialmente si utilizás RStudio, podés saltear esto por ahora. RStudio te avisará y te proporcionará ayuda cuando intentes hacer algo que requiera que configures tu entorno de desarrollo. A continuación están las instrucciones según el sitema operativo que uses.\n\nB.2.1 Windows\n\nSi seguiste los pasos que describimos en Preparando el entorno de trabajo, ya tenés Rtools instalado!\n\nEn Windows, la colección de herramientas necesarias para construir paquetes a partir del código fuente se llama Rtools.\nRtools NO es un paquete de R. NO se instala con install.packages(). En su lugar, descargalo de https://cran.r-project.org/bin/windows/Rtools/ y ejecuta el instalador.\nDurante la instalación de Rtools es posible que aparezca una ventana pidiéndote que “selecciones tareas adicionales”.\n\nSelecciona no en la casilla “Editar el PATH del sistema”. devtools y RStudio deberían poner Rtools en el PATH automáticamente cuando sea necesario.\nSelecciona la casilla “Guardar información de la versión en el registro”. Debería estar seleccionada por defecto.\n\nB.2.2 macOS\nNecesitas instalar las herramientas de línea de comandos de Xcode, lo que requiere que te registres como desarrollador/a de Apple. No te preocupes, esto es gratuito para quien sólo desee instalar apps, como las herramientas de línea de comandos Xcode.\nA continuación, en la terminal escribí:\nxcode-select --install\nAlternativamente, puedes instalar la versión actual de Xcode desde el Mac App Store. Esto incluye una gran cantidad de cosas que no necesitas, pero ofrece la ventaja de la comodidad del App Store.\n\nB.2.3 Linux\nAsegurate de haber instalado no sólo R, sino también las herramientas de desarrollo de R. Por ejemplo, en Ubuntu (y Debian) tienes que instalar el programa r-base-dev con el paquete\nsudo apt install r-base-dev\nEn Fedora y RedHat, las herramientas de desarrollo (llamadas R-core-devel) se instalarán automáticamente cuando instales R con sudo dnf install R.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Configuración para desarrollar paquetes</span>"
    ]
  },
  {
    "objectID": "B_config_pk.html#verifica-la-preparación-del-sistema",
    "href": "B_config_pk.html#verifica-la-preparación-del-sistema",
    "title": "Appendix B — Configuración para desarrollar paquetes",
    "section": "\nB.3 Verifica la preparación del sistema",
    "text": "B.3 Verifica la preparación del sistema\nPodés chequear que todo esté en orden con devtools::dev_sitrep():\n\ndevtools::dev_sitrep()\n#&gt; ── R ───────────────────────────────────────────────────────────────────────\n#&gt; • version: 4.1.2\n#&gt; • path: '/Library/Frameworks/R.framework/Versions/4.1/Resources/'\n#&gt; ── RStudio ─────────────────────────────────────────────────────────────────\n#&gt; • version: 2022.2.0.443\n#&gt; ── devtools ────────────────────────────────────────────────────────────────\n#&gt; • version: 2.4.3.9000\n#&gt; • devtools or its dependencies out of date:\n#&gt;   'gitcreds', 'gh'\n#&gt;   Update them with `devtools::update_packages(\"devtools\")`\n#&gt; ── dev package ─────────────────────────────────────────────────────────────\n#&gt; • package: 'rpkgs'\n#&gt; • path: '/Users/jenny/rrr/r-pkgs/'\n#&gt; • rpkgs dependencies out of date:\n#&gt;   'gitcreds', 'generics', 'tidyselect', 'dplyr', 'tidyr', 'broom', 'gh'\n#&gt;  Update them with `devtools::install_dev_deps()`\n\nSi te indica que algo está desactualizado, te recomendamos que hagas las actualizaciones. En particular si no tenés la última versión de R pero difiere solo en el último número de la versión (por ejemplo tenés 4.4.0 y la última versión es 4.4.1), entonces no es impresindible actualizarlo.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Configuración para desarrollar paquetes</span>"
    ]
  },
  {
    "objectID": "C_soluciones.html",
    "href": "C_soluciones.html",
    "title": "Appendix C — Soluciones de ejercicios",
    "section": "",
    "text": "C.0.1 Capitulo 3 - Lectura de datos\nEste anexo detalla resultados validos para todos los ejercicios desde el capitulo 1 al 6. Recuerda que pueden existir mas de una manera de resolver los ejercicios de forma correcta.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Soluciones de ejercicios</span>"
    ]
  },
  {
    "objectID": "C_soluciones.html#capitulo-4---manipulación-de-datos-ordenados-i",
    "href": "C_soluciones.html#capitulo-4---manipulación-de-datos-ordenados-i",
    "title": "Appendix C — Soluciones de ejercicios",
    "section": "\nC.1 Capitulo 4 - Manipulación de datos ordenados I",
    "text": "C.1 Capitulo 4 - Manipulación de datos ordenados I\n\nEs hora de revisar lo que vimos hasta acá.\n\nDescargá el archivo que se encuentra en este link y guardalo en tu proyecto de trabajo en clase.\nResolvé los ejercicios propuestos de lectura (yapa!) y de filtros. En algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nEl archivo tiene más ejercicios, pero no te adelantes. Vamos a ver esos temas a continuación.\n\n\n\n¿Te acordás del ejercicio que arrancaste cuando vimos filtros? Es hora de completarlo!\n\nCompletá los ejercicios de este archivo que ya deberías tener en tu proyecto.\nTe vas a encontrar con ejercicios para practicar summarise() y mutate(). De nuevo, en algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\nCuando hayas terminado, knitea el archivo para generar un html y ver como queda el resultado.\n\n\n\nC.1.1 Soluciones\nEste archivo incluye ejercicios para practicar como manipular datos usando dplyr. Es importante que guardes este archivo en el proyecto de RStudio que usas durante las clases.\nSeguiremos trabajando con los datos de pingüinos.\nSiempre arrancamos cargando las librerías que vamos a usar. Completá el código y corré el bloque de código para comenzar.\n\n# Cargá las librerias necesarias en este bloque de código\n\nlibrary(dplyr)\nlibrary(readr)\n\nEs momento de leer los datos de pingüinos (si, también hay que practicar leer datos).\n\n# Lectura de datos de pinguinos\npinguinos &lt;- read_csv(here::here(\"datos/pinguinos.csv\"))\n\n\nC.1.1.1 Filtrando datos\nCompletá el código y correlo para verificar el resultado.\n¿Cuántos pingüinos tienen aletas de más de 225 mm?\n\npinguinos |&gt; \n  filter(largo_aleta_mm &gt; 225)\n\n¿Algún pingüino tiene un pico de exactamente 40.9 mm?\n\npinguinos |&gt; \n  filter(largo_pico_mm == 40.9)\n\n¿Cuántos pingüinos hembra hay en la especie Papúa?\n\npinguinos |&gt; \n  filter(especie == \"Papúa\", sexo == \"hembra\")\n\n\nC.1.1.2 Resumiendo los datos\n¿Cuántos pingüinos hay en cada isla?\n\npinguinos |&gt; \n  group_by(isla) |&gt; \n  summarise(n())\n\n¿Todas las especies viven en las mismas islas?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(n())\n\n¿Cuánto pesa el pinguino más liviano y el más pesado de cada especie?\n\npinguinos |&gt; \n  group_by(isla, especie) |&gt; \n  summarise(mas_liviano = min(masa_corporal_g, na.rm = TRUE),\n            mas_pesado = max(masa_corporal_g, na.rm = TRUE))\n\n\nC.1.1.3 Transformando variables\nCalculá la relación entre el alto y el largo del pico (alto_pico_mm/largo_pico_mm)\n\npinguinos |&gt; \n  mutate(pico = alto_pico_mm/largo_pico_mm)\n\nTransformá todas las variables de mm a cm.\n\npinguinos |&gt; \n  mutate(largo_pico_cm = largo_pico_mm/10,\n         alto_pico_cm = alto_pico_mm/10,\n         largo_aleta_cm = largo_aleta_mm/10)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Soluciones de ejercicios</span>"
    ]
  },
  {
    "objectID": "C_soluciones.html#capitulo-6---graficado-datos",
    "href": "C_soluciones.html#capitulo-6---graficado-datos",
    "title": "Appendix C — Soluciones de ejercicios",
    "section": "\nC.2 Capitulo 6 - Graficado datos",
    "text": "C.2 Capitulo 6 - Graficado datos\n\nModificá el siguiente código para obtener el gráfico que se muestra más abajo.\n\npaises |&gt; \n  group_by(continente, _____) |&gt; \n  summarise(esperanza_de_vida_media = mean(esperanza_de_vida)) |&gt; \n  ggplot(aes(anio, ________________)) +  \n  geom_point(aes(color = continente), size = 3, shape = _____) +\n  geom_smooth(color = continente) \n\n\n\nC.2.1 Solucion grafico Esperanza de Vida\n\npaises |&gt; \n  group_by(continente, anio) |&gt; \n  summarise(esperanza_de_vida_media = mean(esperanza_de_vida)) |&gt; \n  ggplot(aes(anio, esperanza_de_vida_media)) +  \n  geom_smooth(aes(color = continente)) +\n  geom_point(aes(color = continente), shape = 8, size = 3) \n\n\nEs hora de revisar lo que vimos hasta acá.\n\nDescargá el archivo que se encuentra en este link y guardalo en tu proyecto de trabajo en clase.\nResolvé los ejercicios propuestos. En algunos casos tendrías que reemplazar los _____ con el código correspondiente. En otros casos el ejercicio te pedirá escribir el código desde cero.\n\n\n\nC.2.2 Soluciones - ejercicios ggplot\nEn este archivo vas a encontrar ejercicios para practicar cómo hacer gráficos con ggplot2. En este caso vamos a usar datos que forman parte de un paquete llamado datos. De hecho este paquete tiene muchas bases de datos en español. Antes de empezar a trabajar recordá instalar este nuevo paquete y el paquete lubridate desde la consola.\n\n# Cargá ggplot2 y dplyr\nlibrary(ggplot2)\nlibrary(dplyr)\n\nclima &lt;- datos::clima #esta es otra manera de acceder a las funciones y datos de un paquete\n\nEsta base de datos tiene datos de distintas variables meterológicas en 3 aeropuertos (en la columna origen) a lo largo de un año. Revisa que columnas incluyen y como se llaman en el siguiente bloque de código.\n\nstr(clima)\n\nHabrás notado que no hay una única columna con la fecha y la hora, está separada en varias columnas, vamos a crear esta columna con mutate() y la función make_datetime() de lubridate.\n\nclima &lt;- clima |&gt; \n  mutate(fecha_hora = lubridate::make_datetime(anio, mes, dia, hora))\n\n¿Cómo es la relación entre el punto de rocio (a que temperatura el vapor de agua se condensa) y la humedad?\n\nggplot(clima, aes(punto_rocio, humedad)) +\n  geom_point()\n\nSumá un suavizado para visuzalizar mejor la relación. Usá el método lm.\n\nggplot(clima, aes(punto_rocio, humedad)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\nVeamos ahora como cambia la temperatura a lo largo del año parada estación. El gráfico resultante debería tener el tiempo en el eje x y mostrar 3 lineas de distinto color, una para cada estación.\n¿En qué parte del mundo están estos aeropuertos?\n\nggplot(clima, aes(fecha_hora, temperatura)) +\n  geom_line(aes(color = origen))\n\n\nGenerá boxplots para analizar como se comporta el precio según la claridad para cada tipo de corte como se ve acá.\n\n\nC.2.3 Solucion Bloxplots\n\nggplot(diamantes, aes(claridad, precio, fill = claridad)) +\n  geom_boxplot() +\n  facet_wrap(~corte)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Soluciones de ejercicios</span>"
    ]
  },
  {
    "objectID": "C_soluciones.html#capitulo-7---manipulacion-de-datos-ii",
    "href": "C_soluciones.html#capitulo-7---manipulacion-de-datos-ii",
    "title": "Appendix C — Soluciones de ejercicios",
    "section": "\nC.3 Capitulo 7 - Manipulacion de Datos II",
    "text": "C.3 Capitulo 7 - Manipulacion de Datos II\n\n\nCreá una nueva tabla, llamada paises_superduper_ancho que tenga una columna para cada variable, anio y país. (Consejo: la tabla final tiene que tener 5 filas).\n¿Cómo es la tabla más ancha posible que podés generar con estos datos? ¿Cuántas filas y columnas tiene?\n\n\n\nC.3.1 Solucion\n\npaises_superduper_ancho &lt;- pivot_wider(paises_largo, \n            names_from = c(variable, anio, pais), \n            names_sep = \"-\",\n            values_from = valor)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Soluciones de ejercicios</span>"
    ]
  },
  {
    "objectID": "D_checklist.html",
    "href": "D_checklist.html",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "",
    "text": "D.1 DESCRIPTION\nA lo largo de las secciones los ejercicios transversales que llamamos “Construyendo un paquete de R paso a paso” son una guía para, justamente, construir un paquete que lee y ayuda a analizar datos meteorológicos.\nA continuación encontrarás una lista de elementos que debe tener o con los que debe cumplir el paquete para estar completo.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  },
  {
    "objectID": "D_checklist.html#description",
    "href": "D_checklist.html#description",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "",
    "text": "Título\nDescripción\nLas personas involucradas estan listadas en Auth@rs",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  },
  {
    "objectID": "D_checklist.html#funciones-y-datos",
    "href": "D_checklist.html#funciones-y-datos",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "D.2 Funciones y datos",
    "text": "D.2 Funciones y datos\n\n(al menos) 3 funciones\n(al menos) 1 set de datos\nLas dependencias están bien definidas",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  },
  {
    "objectID": "D_checklist.html#documentación",
    "href": "D_checklist.html#documentación",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "D.3 Documentación",
    "text": "D.3 Documentación\n\nTodas las funciones y datos están documentados y tienen ejemplos de uso\nIncluye un README con:\n\ncomo instalar el paquete.\nlos autores.\ncomo se puede contribuir al paquete.\n\n\nIncluye una viñeta que explica como usar las funciones\nEl paquete tiene una página web",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  },
  {
    "objectID": "D_checklist.html#tests",
    "href": "D_checklist.html#tests",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "D.4 Tests",
    "text": "D.4 Tests\n\nEl paquete tiene tests que cubren al menos el 75% del código de las funciones\nEl paquete tiene una GitHub action que revisa la covertura de los tests\nEl paquete pasa R CMD checks\nEl paquete tiene una GitHub action que chequea el paquete en distintos sistemas operativos",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  },
  {
    "objectID": "D_checklist.html#otros",
    "href": "D_checklist.html#otros",
    "title": "Appendix D — Checklist para revisar el paquete",
    "section": "D.5 Otros",
    "text": "D.5 Otros\n\nIncluye una licencia\nIncluye un código de conducta\nEl README incluye:\n\netiquetas (covertura de tests, lifecycle, etc).\nun logo para el paquete.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Checklist para revisar el paquete</span>"
    ]
  }
]